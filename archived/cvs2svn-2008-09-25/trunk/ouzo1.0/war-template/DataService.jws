/**
 * This file is a component of the Taverna project,
 * and is licensed under the GNU LGPL.
 * Copyright Tom Oinn, EMBL-EBI
 */

import java.util.*;
import java.io.*;
import org.embl.ebi.escience.baclava.*;
import org.embl.ebi.escience.baclava.store.*;
import org.embl.ebi.escience.baclava.factory.*;
import org.embl.ebi.escience.ouzo.*;
import org.jdom.*;
import org.jdom.output.*;
import org.jdom.input.*;
import org.apache.log4j.*;

/**
 * The SOAP interface wrapping a JDBCBaclavaDataService
 * instance
 * @author Tom Oinn
 */
public class DataService {

    private static Logger log = Logger.getLogger(DataService.class.getName());
    

    /**
     * Get the DataService object from the TavernaLSIDService class,
     * waiting until it's initialized if required
     */
    private static BaclavaDataService theService() {
	BaclavaDataService returnValue = null;
	returnValue = TavernaLSIDService.theDataService;
	while (returnValue == null) {
	    try {
		log.debug("Waiting for dataService object to be created.");
		// Wait until someone initializes the LSID authority
		Thread.sleep(5000);
		returnValue = TavernaLSIDService.theDataService;
	    }
	    catch (InterruptedException ie) {
		//
	    }
	}
	return returnValue;
    }
    

    /**
     * Store a DataThing, returns true if the store proceeded
     * without any errors, false if an exception was thrown.
     */
    public Boolean storeDataThing(String stringifiedThing, Boolean silent) {
	try {
	    // Build the DataThing from the stringified version
	    DataThing theDataThing = null;	
	    try {
		SAXBuilder builder = new SAXBuilder(false);
		Document doc = builder.build(new StringReader(stringifiedThing));
		theDataThing = new DataThing(doc.getRootElement());
	    }
	    catch (JDOMException jde) {
		log.error("JDOM Exception thrown when attempting to parse\na DataThing as XML.",jde);
		return new Boolean(false);
	    }
	    theService().storeDataThing(theDataThing, silent.booleanValue());
	    return new Boolean(true);
	}
	catch (DuplicateLSIDException dle) {
	    return new Boolean(false);
	}
    }
    

    /**
     * Fetch a DataThing in stringified form
     */
    public String fetchDataThing(String LSID)
	throws NoSuchLSIDException {
	DataThing theDataThing = null;
	try {
	    theDataThing = theService().fetchDataThing(LSID);
	}
	catch (NoSuchLSIDException nsle) {
	    log.error("Attempt to fetch non existant LSID "+LSID,nsle);
	    throw nsle;
	}
	String stringifiedDataThing = null;
	Document doc = new Document(DataThingXMLFactory.getElement(theDataThing));
	XMLOutputter xo = new XMLOutputter();
	xo.setIndent("  ");
	xo.setNewlines(true);
	stringifiedDataThing = xo.outputString(doc);
	return stringifiedDataThing;
    }
    
    
    /**
     * Check whether the supplied LSID has data
     */
    public boolean hasData(String LSID) {
	return theService().hasData(LSID);
    }


    /**
     * Check whether the supplied LSID has metadata
     */
    public boolean hasMetadata(String LSID) {
	return theService().hasMetadata(LSID);
    }


    /**
     * Store a string containing RDF format metadata
     * and one or more LSIDs as resources
     */
    public void storeMetadata(String theMetadata) {
	theService().storeMetadata(theMetadata);
    }

    
    /**
     * Returns a string of all the metadata statements
     * that reference the given LSID
     */
    public String getMetadata(String LSID) {
	return theService().getMetadata(LSID);
    }


    /**
     * If the data service is also an instance of LSIDProvider
     * then expose this method
     */
    public String getID(String namespace) {
	try {
	    return ((LSIDProvider)theService()).getID(namespace);
	}
	catch (ClassCastException cce) {
	    log.error("Attempt to user the LSIDProvider interface when\nthe underlying"+
		      " data store isn't an implementation of it.",cce);
	    return "";
	}
    }

}

