<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
body {
	font-family: Arial, Helvetica, sans-serif;
	background-color: #FFFFFF;
	text-align: justify;
	font-size: x-small;
}
ol {
	background-color: #CCCCFF;
	padding: 4px;
	height: auto;
	width: auto;
	border: thin solid;
	list-style-type: lower-roman;
}
-->
</style>
<style type="text/css">
<!--
pre {
	text-indent: 0px;
	background-color: #FFFFCC;
	border: thin solid;
	padding: 10px;
	height: auto;
	width: auto;
	left: 20px;
	font-size: small;
}
-->
</style>
</head>

<body>
<h1>Data Types and Representation in <sup>my</sup>Grid</h1>
<p>Tom Oinn, <a href="mailto:tmo@ebi.ac.uk">tmo@ebi.ac.uk</a>, 5<sup>th</sup> 
  August 2003</p>
<p><em>Planning / Design / Straw Man for IF5</em></p>
<h2>Background</h2>
<p>Having worked on the current myGrid enactor and workflow framework as part 
  of the Taverna project, it has become clear that the internal data format needs 
  to be properly considered and standardised. This has been largely as a result 
  of the evolution of the codebase and feature set - it is a well known software 
  engineering principle that your architecture and implementation can only evolve 
  up to a point before a reworking or re-engineering is required at some level. 
  In our case, this has largely come about because of a conflict between the original 
  design of the enactor and subsequent feature requirements. Specifically :</p>
<ol>
  <li>The enactor was designed to be 'data agnostic', in that the enactment engine 
    itself never required any knowledge about the data it passed between worker 
    processors. This was, and is, a sensible design decision; it makes sense that 
    in an unbounded universe of potential types of data (we cannot control the 
    rest of the world) we should only desire to comprehend any given item of data 
    to the extent that it influences decisions about how to handle that data. 
    In general, the enactor does not need to know that a particular data item 
    is a string containing a protein sequence in order to pass this between workers.</li>
  <li>Subsequent to this choice and implementation, we decided that we wished 
    to support so called implicit iterators; these were intended to allow links 
    between processor units where the underlying data types were compatible but 
    mismatched in terms of cardinality. A typical example would be an array of 
    strings being passed into a web service that accepts a single string, this 
    system allows the enactor to automatically construct appropriate iterators 
    and behave in the way the user would naively expect, thus following the 'principle 
    of least surprise'.</li>
</ol>
<p>Unfortunately, these two points are in conflict as it stands. There is no mechanism 
  presently in place to allow information about the cardinality (set, list, array, 
  graph etc) of the data to be regarded in an independant manner to that about 
  the type of each individual data item. Thus far, the support that is present 
  consists of a series of temporary hacks largely dictated by the time pressures 
  of previous demos and integration fests, however, this has left the current 
  codebase somewhat tangled and really does need to be addressed properly.</p>
<h2>Desired functionality</h2>
<p>We have a set of requirements in light of our experience to this point. These 
  requirements are workflow and user interface centric, and may therefore not 
  be exhaustive. We would welcome input from the other teams working on systems, 
  in particular the information repository and distributed query subsystem, that 
  have to handle this information. With that in mind, here are the requirements 
  isolated thus far.</p>
<ol>
  <li>We cannot restrict the workflow system to only passing data that we are 
    aware of at any given time. There will always be data types out in the wild 
    that we haven't yet seen, so whatever mechanism we adopt must be able to cope 
    with arbitrary data items at some level.</li>
  <li>We require some information regarding the cardinality or pattern of the 
    data items within a collection of data items. At this level we would regard 
    the collection as the data for purposes of enactment and storage.</li>
  <li>Such collections must be adequate to represent all such possible multiple 
    data patterns, bearing in mind that the potential dimensionality of data in 
    scientific experiments is unbounded, and that collections may be (partially) 
    ordered.</li>
  <li>There must be sufficient metadata attached to the collection to allow visualization 
    of the items contained within, and the structure of the collection itself.</li>
  <li>There must be a location to specify arbitrary ontological metadata applying 
    to the data items.</li>
  <li>The carrier syntax should be XML based.</li>
</ol>
<p>With these requirements in mind, I suggest the following design features.</p>
<ol>
  <li>Treat all data objects as partially ordered sets of data elements or data 
    objects.</li>
  <li>Treat all data elements as chunks of binary data encoded using the BASE64 
    standard.</li>
  <li>Attach to each data object a MIME type that is correct for all data elements 
    within that data object.</li>
  <li>Attach to each data element an area to be used to store ontology based information, 
    perhaps as a chunk of RDF but I'm open to suggestions by people who actually 
    understand ontologies for this one.</li>
</ol>
<p>By treating all information as arbitrary deeply nested partial orders of atomic 
  data elements we can represent all possible collections of data that we have 
  either encountered or envisaged. For those not familiar with partial orders 
  they can be used to represent lists, sets, directed acyclic graphs and in the 
  degenerate case single items. By allowing partial orders of partial orders we 
  can represent multidimensional arrays, sets of trees etc. I claim this is sufficient 
  for the data representation requirements outlined above.</p>
<p>Encoding all data elements as BASE64 strings is an explicit separation of data 
  item type and collection type. This allows systems such as the enactor to maintain 
  their 'data agnostic' approach while still retaining the implicit iteration 
  facilities that have proven to be required for certain tasks.</p>
<p>MIME types are a standard that has evolved to cope with internet email attachments. 
  The requirements for this standard are to allow an email program or web browser 
  to select appropriate rendering or other handler code for data visualization. 
  Obviously this alone doesn't address the requirements for data description within 
  <sup>my</sup>Grid, but see next paragraph.</p>
<p>In order to allow more complex description it should be possible to attach 
  semantic metadata to each data element. <font color="#FF0000">I suggest that 
  the information should be per element rather than per set, is there a justification 
  otherwise, or to attach additional metadata to the set as a whole?</font> I 
  suspect the second of those is probable, but don't know enough of the semantics 
  part of the project. Phil? Chris?</p>
<h2>Implementation</h2>
<p>Although naively encoding the above spec in XML would work fine, there are 
  situations where some denormalisation of the metadata would be useful. Specifically, 
  it would be possible to determine the collection type (set, list, tree etc) 
  from the ordering information, but this operation is both common and time consuming. 
  Common because we will require operations to convert from the data document 
  into Java object types, and time consuming because these operations are potentially 
  polynomial graph operations over the relations in the set. In order to avoid 
  this, we can embed hints about the collection type in the collection tag. I 
  suggest that the types of collection are as follows.</p>
<ol>
  <li>Set - no ordering on any elements, maps to Java set types.</li>
  <li>Total order, Array, List - total order over all elements, maps to Java array 
    types</li>
  <li>Tree - partial order, single root node, standard tree relations apply i.e. 
    single parent and zero or more children. Can be mapped to Java tree types.</li>
  <li>Partial order, Graph - arbitrary acyclic relations over the set, superset 
    of all of the above and therefore default. I am not aware of a general PoSet 
    implementation in Java so we might have to create one as part of the implementation 
    component of this spec.</li>
</ol>
<p>The schema diagram below summarizes my first cut at an XML structure for the 
  data document. As far as I can see, this fills all the requirements we have 
  from the workflow and rendering persepective.</p>
<p align="center"><img src="MyGridDataDocumentSchema.png" width="1009" height="488"></p>
<p>The section below shows an example of how a list of trees of PNG images would 
  be represented. </p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!-- Example document to show a list of trees of PNG images (well, they could be, really they're just made up strings) --&gt;<br>&lt;MyGridDataDocument mimetype=&quot;IMAGE/PNG&quot; 
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
 xsi:noNamespaceSchemaLocation=&quot;C:\Documents and Settings\Tom\Desktop\MyGridDataDocument.xsd&quot;&gt;<br>	&lt;MyGridDocumentMetadata&gt;<font color="#FF0000">foo... bar... more RDF here perhaps?</font>&lt;/MyGridDocumentMetadata&gt;<br>	&lt;PartialOrder type=&quot;list&quot; index=&quot;0&quot;&gt;<br>		&lt;RelationList&gt;<br>			&lt;Relation parent=&quot;0&quot; child=&quot;1&quot;/&gt;<br>		&lt;/RelationList&gt;<br>		&lt;PartialOrderList&gt;<br>			&lt;PartialOrder type=&quot;tree&quot; index=&quot;0&quot;&gt;<br>				&lt;RelationList&gt;<br>					&lt;Relation parent=&quot;0&quot; child=&quot;1&quot;/&gt;<br>					&lt;Relation parent=&quot;0&quot; child=&quot;2&quot;/&gt;<br>					&lt;Relation parent=&quot;1&quot; child=&quot;3&quot;/&gt;<br>				&lt;/RelationList&gt;<br>				&lt;DataElementList&gt;<br>					&lt;DataElement index=&quot;0&quot;&gt;<br>						&lt;DataElementData&gt;
							&lt;![CDATA[fkjshdfkjshdfkjhsdkjfskjdhfskjdhfsjkhdfsdf]]&gt;
						&lt;/DataElementData&gt;<br>						&lt;DataElementMetaData&gt;<font color="#FF0000">foo? RDF here?</font>&lt;/DataElementMetaData&gt;<br>					&lt;/DataElement&gt;<br>					&lt;DataElement index=&quot;1&quot;&gt;<br>						&lt;DataElementData&gt;
							&lt;![CDATA[sdfkjsdfkjhsdkjfhsdkjfhskdjhfksjdhfkjshdfkjhh]]&gt;
						&lt;/DataElementData&gt;<br>						&lt;DataElementMetaData&gt;<font color="#FF0000">foo? RDF here?</font>&lt;/DataElementMetaData&gt;<br>					&lt;/DataElement&gt;<br>					&lt;DataElement index=&quot;2&quot;&gt;<br>						&lt;DataElementData&gt;
							&lt;![CDATA[sdlkfjsdlkjfsdlkjfldkjgwelkrjsaldkjfsdflkjsdfljksdf]]&gt;
						&lt;/DataElementData&gt;<br>						&lt;DataElementMetaData&gt;<font color="#FF0000">foo? RDF here?</font>&lt;/DataElementMetaData&gt;<br>					&lt;/DataElement&gt;<br>					&lt;DataElement index=&quot;3&quot;&gt;<br>						&lt;DataElementData&gt;
							&lt;![CDATA[sdlkfjsdlkjfsdlkjfldkjgwelkrjsaldkjfsdflkjsdfljksdf]]&gt;
						&lt;/DataElementData&gt;<br>						&lt;DataElementMetaData&gt;<font color="#FF0000">foo? RDF here?</font>&lt;/DataElementMetaData&gt;<br>					&lt;/DataElement&gt;<br>				&lt;/DataElementList&gt;<br>			&lt;/PartialOrder&gt;<br>			&lt;PartialOrder type=&quot;tree&quot; index=&quot;1&quot;&gt;<br>				&lt;RelationList&gt;<br>					&lt;Relation parent=&quot;0&quot; child=&quot;1&quot;/&gt;<br>					&lt;Relation parent=&quot;0&quot; child=&quot;2&quot;/&gt;<br>				&lt;/RelationList&gt;<br>				&lt;DataElementList&gt;<br>					&lt;DataElement index=&quot;0&quot;&gt;<br>						&lt;DataElementData&gt;
							&lt;![CDATA[fkjshdfkjshdfkjhsdkjfskjdhfskjdhfsjkhdfsdf]]&gt;
						&lt;/DataElementData&gt;<br>						&lt;DataElementMetaData&gt;<font color="#FF0000">foo? RDF here?</font>&lt;/DataElementMetaData&gt;<br>					&lt;/DataElement&gt;<br>					&lt;DataElement index=&quot;1&quot;&gt;<br>						&lt;DataElementData&gt;
							&lt;![CDATA[sdfkjsdfkjhsdkjfhsdkjfhskdjhfksjdhfkjshdfkjhh]]&gt;
						&lt;/DataElementData&gt;<br>						&lt;DataElementMetaData&gt;<font color="#FF0000">foo? RDF here?</font>&lt;/DataElementMetaData&gt;<br>					&lt;/DataElement&gt;<br>					&lt;DataElement index=&quot;2&quot;&gt;<br>						&lt;DataElementData&gt;
							&lt;![CDATA[sdlkfjsdlkjfsdlkjfldkjgwelkrjsaldkjfsdflkjsdfljksdf]]&gt;
						&lt;/DataElementData&gt;<br>						&lt;DataElementMetaData&gt;<font color="#FF0000">foo? RDF here?</font>&lt;/DataElementMetaData&gt;<br>					&lt;/DataElement&gt;<br>				&lt;/DataElementList&gt;<br>			&lt;/PartialOrder&gt;<br>		&lt;/PartialOrderList&gt;<br>	&lt;/PartialOrder&gt;<br>&lt;/MyGridDataDocument&gt;</pre>
<p>The XSD for the above is something like :</p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!-- edited with XML Spy v4.2 U (http://www.xmlspy.com) by Tom Oinn (EBI) --&gt;<br>&lt;!--W3C Schema generated by XML Spy v4.2 U (http://www.xmlspy.com)--&gt;<br>&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; elementFormDefault=&quot;qualified&quot;&gt;<br>	&lt;xs:element name=&quot;DataElement&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				A single item of data within the myGrid framework.
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>		&lt;xs:complexType&gt;<br>			&lt;xs:sequence&gt;<br>				&lt;xs:element ref=&quot;DataElementData&quot;/&gt;<br>				&lt;xs:element ref=&quot;DataElementMetaData&quot;/&gt;<br>			&lt;/xs:sequence&gt;<br>			&lt;xs:attribute name=&quot;index&quot; type=&quot;xs:byte&quot; use=&quot;required&quot;/&gt;<br>		&lt;/xs:complexType&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;DataElementData&quot; type=&quot;xs:string&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				Contains a CDATA block with the Base64 encoded representation of the data.
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;DataElementList&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;A list of data elements.&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>		&lt;xs:complexType&gt;<br>			&lt;xs:sequence&gt;<br>				&lt;xs:element ref=&quot;DataElement&quot; maxOccurs=&quot;unbounded&quot;/&gt;<br>			&lt;/xs:sequence&gt;<br>		&lt;/xs:complexType&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;DataElementMetaData&quot; type=&quot;xs:string&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				<font color="#FF0000">Per data element semantic metadata, probably in RDF.</font>
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;MyGridDataDocument&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				Top level container for a collection of data within the myGrid framework.
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>		&lt;xs:complexType&gt;<br>			&lt;xs:sequence&gt;<br>				&lt;xs:element ref=&quot;MyGridDocumentMetadata&quot;/&gt;<br>				&lt;xs:element ref=&quot;PartialOrder&quot;/&gt;<br>			&lt;/xs:sequence&gt;<br>			&lt;xs:attribute name=&quot;mimetype&quot; type=&quot;xs:string&quot; use=&quot;required&quot; default=&quot;TEXT/PLAIN&quot;/&gt;<br>		&lt;/xs:complexType&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;MyGridDocumentMetadata&quot; type=&quot;xs:string&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				<font color="#FF0000">Semantic metadata that is valid for the complete document as opposed to that which 
				only applies to single data elements within it.</font>
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;PartialOrder&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				A partially ordered set of data within the document, this contains either a set of data 
				elements or a set of partial orders, allowing arbitrary recursion.
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>		&lt;xs:complexType&gt;<br>			&lt;xs:sequence&gt;<br>				&lt;xs:element ref=&quot;RelationList&quot; minOccurs=&quot;0&quot;/&gt;<br>				&lt;xs:choice&gt;<br>					&lt;xs:element ref=&quot;DataElementList&quot;/&gt;<br>					&lt;xs:element ref=&quot;PartialOrderList&quot;/&gt;<br>				&lt;/xs:choice&gt;<br>			&lt;/xs:sequence&gt;<br>			&lt;xs:attribute name=&quot;type&quot; type=&quot;xs:string&quot; use=&quot;required&quot; default=&quot;partialorder&quot;/&gt;<br>			&lt;xs:attribute name=&quot;index&quot; type=&quot;xs:int&quot; use=&quot;required&quot; default=&quot;0&quot;/&gt;<br>		&lt;/xs:complexType&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;PartialOrderList&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;A list of partial orders.&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>		&lt;xs:complexType&gt;<br>			&lt;xs:sequence&gt;<br>				&lt;xs:element ref=&quot;PartialOrder&quot; maxOccurs=&quot;unbounded&quot;/&gt;<br>			&lt;/xs:sequence&gt;<br>		&lt;/xs:complexType&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;Relation&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				Defines a single ordering relation between two elements, referencing elements by 
				integer index.
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>		&lt;xs:complexType&gt;<br>			&lt;xs:attribute name=&quot;parent&quot; type=&quot;xs:int&quot; use=&quot;required&quot;/&gt;<br>			&lt;xs:attribute name=&quot;child&quot; type=&quot;xs:int&quot; use=&quot;required&quot;/&gt;<br>		&lt;/xs:complexType&gt;<br>	&lt;/xs:element&gt;<br>	&lt;xs:element name=&quot;RelationList&quot;&gt;<br>		&lt;xs:annotation&gt;<br>			&lt;xs:documentation&gt;
				Where present, this defines one or more relations between elements in the partial order it is a child of. 
				If absent then there are no relations explicitly defined, although the type of the partial order can override 
				this; if the type is 'list' then there is an implicit ordering by integer index.
			&lt;/xs:documentation&gt;<br>		&lt;/xs:annotation&gt;<br>		&lt;xs:complexType&gt;<br>			&lt;xs:sequence&gt;<br>				&lt;xs:element ref=&quot;Relation&quot; maxOccurs=&quot;unbounded&quot;/&gt;<br>			&lt;/xs:sequence&gt;<br>		&lt;/xs:complexType&gt;<br>	&lt;/xs:element&gt;<br>&lt;/xs:schema&gt;</pre>
</p>
</body>
</html>
