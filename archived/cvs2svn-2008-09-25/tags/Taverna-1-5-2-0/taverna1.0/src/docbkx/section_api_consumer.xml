<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section>
  <title>API Consumer</title>

  <para>The API Consumer allows the selection of subsets of Java APIs which
  may then be imported into Taverna's workbench software and used as
  components within workflows in that environment. This tool is intended for
  API developers rather than end users, it produces an XML API definition file
  which Taverna imports - it is this file that you can distribute alongside or
  within your API to 'Taverna enable' it.</para>

  <section>
    <title>Prerequisites</title>

    <para>The API Consumer is a Java Doclet and uses Ant to launch, you must
    therefore have a Java JDK and Ant installed and available on the path. In
    addition the '<emphasis role="bold">tools.jar</emphasis>' file from the
    JDK must be available on the classpath, you can copy it into the <emphasis
    role="bold">jre/lib/ext</emphasis> directory within your JDK installation
    with no unpleasant side effects.</para>
  </section>

  <section>
    <title>Setup</title>

    <para>Before running the API Consumer you need to place any target source
    files within the 'target' directory and any supporting libraries required
    in the 'lib' directory. This is particularly important - if your API
    includes methods which consume or return a type that isn't available to
    the API Consumer the definitions it generates will be invalid. For
    example, if your API contains a method '<emphasis role="bold">void
    foo(MagicClass bar)</emphasis>' and the <emphasis
    role="bold">MagicClass</emphasis> is in some random package in a third
    party jar file that you haven't included there's no way for the doclet to
    know the fully qualified classname of <emphasis
    role="bold">MagicClass</emphasis>. As Taverna's plugin requires full
    classnames this will result in an API that can't be invoked from the
    workflow. You can normally trap these issues by watching for the standard
    javadoc warning messages in the console.</para>
  </section>

  <section>
    <title>Usage</title>

    <para>Once your source and any supporting files are present as described
    above you can either call ant directly (just type 'ant' on the command
    line while in the API consumer directory) or, on windows machines, by
    running the 'runme.bat' file. The API consumer itself will be built from
    source and applied to the target source files, after some slight delay for
    this process (longer for very complex APIs) you should see a screen such
    as the following:</para>

    <screenshot>
      <screeninfo></screeninfo>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/apic_initialwindow.png" />
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>The tree on the left hand side of the window shows the available
    classes (including inner classes where present) along with a search box -
    the right hand side currently shows nothing. Selecting a class from the
    tree produces a display like the following, this should be clearly similar
    to the information produced by the standard javadoc tool:</para>

    <screenshot>
      <screeninfo></screeninfo>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/apic_summarydisplay.png" />
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>In the case of large APIs the search box can be used to display a
    subset of the complete class tree - enter a pattern to match and hit
    return in this text box and the tree will be expanded to show all matching
    nodes. To return to the view with all nodes expanded clear the text in
    this box and hit return.</para>
  </section>

  <section>
    <title>Adding methods to API definition</title>

    <para>The next step is to select methods to add to the API definition -
    these methods (static, instance or constructors) will appear as components
    within Taverna's workbench when the definition file is imported.</para>

    <para><emphasis role="bold">Using Graphical Interface</emphasis></para>

    <para>Methods can be manually added by choosing the class, opening the
    '<emphasis role="bold">Methods</emphasis>' tab and either selecting
    individual methods or using the '<emphasis role="bold">Select
    all</emphasis>' and '<emphasis role="bold">Clear all</emphasis>'
    boxes:</para>

    <screenshot>
      <screeninfo></screeninfo>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/apic_methods.png" />
        </imageobject>
      </mediaobject>
    </screenshot>

    <para><emphasis role="bold">Using JavaDoc tags</emphasis></para>

    <para>For APIs under your direct control there is an alternative based on
    JavaDoc tags. By adding the tag '@taverna.consume' to either classes or
    individual methods you can automatically have these methods selected in
    the API consumer when it first scans the source files. In the case of the
    tag at a class or interface level all constructors and methods will be
    selected.</para>
  </section>

  <section>
    <title>API level metadata.</title>

    <para>To aid use of your exported API you can select the '<emphasis
    role="bold">API Description</emphasis>' tab and use it to provide a name
    and description for the entire API subset:</para>

    <screenshot>
      <screeninfo></screeninfo>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/apic_description.png" />
        </imageobject>
      </mediaobject>
    </screenshot>
  </section>

  <section>
    <title>Saving the API definition file.</title>

    <para>To save the API definition select the '<emphasis
    role="bold">File</emphasis>' -&gt; '<emphasis role="bold">Save as
    XML</emphasis>'. This should bring up a standard save dialogue, choose a
    filename and save. This is the file that is then imported into Taverna's
    scavenger panel.</para>
  </section>
</section>