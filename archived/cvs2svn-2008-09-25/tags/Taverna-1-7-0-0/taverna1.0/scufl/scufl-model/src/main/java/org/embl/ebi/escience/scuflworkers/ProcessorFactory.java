/**
 * This file is a component of the Taverna project,
 * and is licensed under the GNU LGPL.
 * Copyright Tom Oinn, EMBL-EBI
 */
package org.embl.ebi.escience.scuflworkers;

import org.embl.ebi.escience.scufl.DuplicateProcessorNameException;
import org.embl.ebi.escience.scufl.Processor;
import org.embl.ebi.escience.scufl.ProcessorCreationException;
import org.embl.ebi.escience.scufl.ScuflModel;
import org.embl.ebi.escience.scufl.parser.XScuflFormatException;
import org.jdom.Element;

/**
 * Implementing classes are capable of creating a new processor and attaching it
 * to a model when supplied with the new processor name and a reference to the
 * model. The intention is that service scavengers should create an
 * implementation of this for each service they find and that these should then
 * be used as the user objects inside a default tree model to allow simple
 * service selection and addition to a ScuflModel
 * 
 * @author Tom Oinn
 */
public abstract class ProcessorFactory {

	private String name = "";

	private String description = null;

	/**
	 * Instantiate a new processor with the supplied name and bind it to the
	 * specified model. This in turn uses the XML handling code defined by the
	 * XMLHandler and the fragment generated by the getXMLFragment() method.
	 */
	public final Processor createProcessor(String name, ScuflModel model) throws ProcessorCreationException,
			DuplicateProcessorNameException {
		// Wrap the fragment in a 'processor' element and despatch it to the
		// ProcessorHelper method.
		Element wrapperElement = new Element("wrapper");
		wrapperElement.addContent(getXMLFragment());
		try {
			Processor newProcessor = ProcessorHelper.loadProcessorFromXML(wrapperElement, model, name);
			if (newProcessor == null) {
				throw new ProcessorCreationException("Failed to find processor for: " + wrapperElement);
			}

			if (model != null) {
				model.addProcessor(newProcessor);
			}
			return newProcessor;
		} catch (XScuflFormatException xfe) {
			throw new ProcessorCreationException("Invalid internal XML representation!", xfe);
		}
	};

	/**
	 * Describe the processor that would be created by this factory were the
	 * createProcessor method invoked
	 */
	public abstract String getProcessorDescription();

	/**
	 * Return the Class object describing the processor this factory would build
	 */
	public abstract Class getProcessorClass();

	/**
	 * Return the XML 'spec' element that this factory will use to build its
	 * processor instances
	 */
	public final Element getXMLFragment() {
		// Use the processor class to find the appropriate
		// tag and thence XML handler implementation
		String tagName = ProcessorHelper.getTagNameForClassName(getProcessorClass().getName());
		XMLHandler xh = (XMLHandler) ProcessorHelper.getXMLHandlerForTagName(tagName);
		return xh.elementForFactory(this);
	}

	/**
	 * Get a name for this factory
	 */
	public final String getName() {
		return this.name;
	}

	/**
	 * Set the name
	 */
	public final void setName(String newName) {
		this.name = newName;
	}

	/**
	 * Set the description
	 */
	public final void setDescription(String newDescription) {
		this.description = newDescription;
	}

	/**
	 * Get a description for the factory
	 */
	public final String getDescription() {
		return this.description;
	}

	public final String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append("<html>");
		sb.append("<font color=\"black\">");
		sb.append(getName());
		if (getDescription() != null) {
			sb.append("</font> - <font color=\"green\">");
			sb.append(getDescription());
		}
		sb.append("</font></html>");
		return sb.toString();
	}

}
