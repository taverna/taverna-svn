<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
body {
	font-family: Arial, Helvetica, sans-serif;
	text-align: justify;
}
-->
</style>
</head>

<body>
<h1>Available Taverna Sub-projects</h1>
<p>This document describes some subprojects for Taverna that vary in complexity 
  from intermediate to advanced, and that the core team is unlikely to have resources 
  to implement in the near future. These are mostly additional features that have 
  been requested by end users, but ones that neither require core software modifications 
  nor massively involved knowledge of the service architecture used by the project 
  as a whole. Hopefully these will make decent short projects for anyone interested 
  in getting involved, especially those who cannot commit massive amounts of time 
  or effort. In short, these things would be good to have in the code but are 
  in no way essential.</p>
<p>More details of the Taverna project are available at <a href="http://taverna.sf.net">taverna.sf.net</a>.</p>
<p>If you're interested in any of these projects, please join the mailing lists 
  accessible from the sourceforge site above and let us know. If for some reason 
  you can't do this then please contact Tom Oinn at <a href="mailto:tmo@ebi.ac.uk">tmo@ebi.ac.uk</a> 
  for more details.</p>
<h2>Contents</h2>
<ol>
  <li><a href="#1">Web button support for service or workflow load</a></li>
  <li><a href="#2">Collection of processor prototypes from a workflow definition</a></li>
  <li><a href="#3">Graphical workflow progress display</a></li>
  <li><a href="#4">Show annotations on processors and data links</a></li>
  <li><a href="#5">Wizard for DataThing construction</a></li>
</ol>
<h2><a name="1"></a>1 Web button support for service or workflow load</h2>
<h3>Background and aim</h3>
<p>The current mechanisms for the loading of workflows or addition of services 
  into the service selection panel require users to enter possibly cryptic URLs 
  to the appropriate resource. In particular, the web service scavengers require 
  the address of a WSDL document. In an ideal world, our end users would never 
  be confronted with such documents, even in the passing manner that they currently 
  do so.</p>
<p>The AmphetaDesk project (<a href="http://www.disobey.com/amphetadesk/">http://www.disobey.com/amphetadesk/</a>) 
  is an RSS based news program. This software collects information from XML feeds 
  such as those provided by news sites, slashdot etc, and displays them in an 
  integrated fashion to the user. This aspect of the software is not particularly 
  relevent to Taverna, however they address the same problem as we do. The AmphetaDesk 
  software needs to know the URL of the RSS document, and yet most users of it 
  will not want to know the details of how this is done. The solution they came 
  up with is for the client application to include a very simple embedded webserver 
  listening on localhost on some defined high number port. When a news site wishes 
  to be compatible with AmphetaDesk they create a button with a link that looks 
  something like the following:</p>
<pre>http://127.0.0.1:8888/index.html?add_url=http://sourceforge.net/export/rss2_projnews.php?group_id=74874&amp;go</pre>
<p>As you should be able to see, this link, when activated in a web browser, will 
  send a request to the local web server running on port 8888, which is the one 
  used by the AmphetaDesk embedded server. This server therefore receives the 
  request and is able to extract the URL of the RSS document to add to the application. 
  As far as the end user is concerned, they click on a button on the web page 
  and their news client suddenly has a new feed - they see nothing of the details 
  of exactly where the feed comes from or how it was accessed, and they don't 
  need to enter the URL or any other configuration data.</p>
<p>It should be fairly obvious that similar functionality could be used in Taverna. 
  For example, we could have a 'add service to workbench' graphic which service 
  providers could add to their web pages, linking appropriately such that when 
  clicked the service would be automatically loaded into the service selection 
  panel. By extending the scheme to include additional data in the link, similar 
  operations could be performed for workflows (load into the workbench when the 
  user clicks the link) or other entities that currently require the user to enter 
  a URL</p>
<h3>Requirements</h3>
<p>A knowledge of multithreaded java programming with some level of experience 
  of writing network code would be an advantage, but is probably not essential 
  - just bear in mind that if you haven't written something like this before then 
  it might take some time to learn all the basic technology required (this would 
  be useful anyway). The interaction points with the Taverna codebase are fairly 
  simple, effectively you'll be adding code to the service selection panel component 
  which is a relatively sane swing component, your code has very little direct 
  interaction with Taverna, obviously the Taverna core team will provide assistance 
  to anyone trying to write this!</p>
<p>It'd be good if whoever was writing this would also design a decent logo for 
  the button to be used as the link, but that's optional!</p>
<h3>Time required</h3>
<p>I reckon I could code this in a day at most. I am, however, an expert programmer 
  with far too much familiarity with Taverna, so it would be more reasonable to 
  allow a week or two depending on your Java expertise. This is not a critical 
  component of Taverna so take as long as you like, but it is possible to code 
  this relatively quickly.</p>
<h2><a name="2"></a>2 Collection of processor prototypes from a workflow definition</h2>
<h3>Background and aim</h3>
<p>The prototype design pattern is based on constructing an exemplar object and 
  cloning it to produce copies that are then used, possibly after some level of 
  configuration. In Taverna we don't use this pattern at all when creating new 
  processor instances, instead we use an abstract specification in conjunction 
  with a factory model. This approach is reasonable, but fails to support a couple 
  of commonly requested features.</p>
<p>With the growing amount of user supplied data that can be added to a processor 
  in a workflow, it becomes more useful to be able to reuse workflows that users 
  have created in the past as a source of processor specifications. This would 
  allow, for example, user supplied descriptions to be reused in a subsequent 
  workflow. In order to accomplish this we would like to have the ability to load 
  a workflow definition into the service selection panel, this would appear as 
  a top level node something like 'processor from workflow foo' with child nodes 
  named after the processors within that workflow. These child nodes would effectively 
  create copies of those processor nodes, requesting a new name from the user, 
  and add them to the current workflow.</p>
<h3>Deep clone support</h3>
<p>Deep cloning of an object consists generally of serializing it out to some 
  alternate form then deserializing it back, effectively creating a complete copy 
  of the object including copies of any referenced objects. In Taverna, this can 
  be accomplished by making use of the XML handler support for the various processor 
  types. Specifically, you could choose either to load the workflow definition 
  into a complete workflow model and then clone processor from there, or to parse 
  the workflow definition yourself to populate the child nodes in the service 
  selection panel with the appropriate XML fragments, using these to generate 
  processor implementations via the same mechanisms that the current XScufl loader 
  code makes use of.</p>
<h3>Requirements</h3>
<p>This project requires a reasonable knowledge of Taverna's code, especially 
  the service selection panel and the processor plugin architecture. In addition 
  a knowledge of XML parsing, probably with the JDom toolkit, would make your 
  life massively easier. The plugin frameworks of Taverna make extensive use of 
  the Java reflection APIs, so familiarity with these will make life easier, although 
  you can probably get away with never actually using this part of the code.</p>
<h3>Time required</h3>
<p>To implement and test this fully will take some time, probably around a week 
  for someone already familiar with XML handling and Taverna, and correspondingly 
  longer times for those needing to learn these technologies. JDom (www.jdom.org) 
  is a relatively simple Java XML handler toolkit, and well worth learning in 
  any case, the various parts of Taverna could also take some time. </p>
<h2><a name="3"></a>3 Graphical workflow progress display</h2>
<h3>Background and aim</h3>
<p>Taverna includes a graphical read only view of the workflow. This view is generated 
  using the dot tool from AT&amp;T research, part of the GraphViz package. Internally 
  this is implemented as a DotView class within the scufl.view package; this class 
  provides a view on the bound workflow model in the form of a dot text document; 
  in order to render this we pipe it out to an external dot binary which returns 
  a png image that is then displayed.</p>
<p>In addition, during workflow invocation, we show a progress table. This contains 
  one row for each processor in the workflow, and columns describing start time, 
  end time and current status.</p>
<p>It should be possible to adapt the dot view code to generate a similar view 
  that is colour coded according to the status messages used by the status view. 
  This would allow the user to see the workflow gradually changing colour corresponding 
  to the current workflow progress, which would be really quite nifty.</p>
<h3>Requirements</h3>
<p>A familiary with swing (to create the gui components), dot (to generate the 
  view in the first place) and XML handling (to interpret the progress report) 
  would make this a very quick project. None of these are especially hard, and 
  all are useful so feel free to grab this even if you don't currently know all 
  these technologies. There is a certain amount of interaction with Taverna's 
  code, but this is fairly minimal due to the plugin architecture used in the 
  gui. We would expect most of the code to be written outside of the Taverna workbench, 
  and then integrated in collaboration with the Taverna core team as a final stage.</p>
<h3>Time required</h3>
<p>Assuming familiarity with all the above technologies, this can be implemented 
  fairly quickly. Allow correspondingly more time if you have no swing experience 
  or need to learn how to use JDom. The language used by dot is extremely simple 
  and there are plenty of examples in the code so this shouldn't take more than 
  a couple of days to learn, the requisite bits of Taverna might take slightly 
  longer. Assume that with no prior experience this is possible within three or 
  four weeks.</p>
<h2><a name="4"></a>4 Show annotations on processors and data links</h2>
<h3>Background</h3>
<p>Complex workflows, whilst hopefully simpler to understand than the equivalent 
  scripts, can still be confusing. While free text descriptions may be added to 
  processor instances, we cannot add them to data links or coordination constraints, 
  and there is no way to get a visual summary of the annotations in any of the 
  workflow views.</p>
<p>It would be neat if we could effectively add 'postit' type notes to all the 
  entities in the workflow, and allow an optional flag to display these in the 
  graphical view, hopefully this would make reuse of workflows simpler.</p>
<h3>Requirements</h3>
<p>Very few, you'd need to add some code to the dot view, which implies at least 
  a passing knowledge of the dot language, and basic Java to add description fields 
  and editors to the data and coordination constraint objects. To do this fully 
  you'll also have to add code to the XML load and save code, so there are plenty 
  of bits here and there to do but nothing too complex.</p>
<h3>Time required</h3>
<p>A Java expert should be able to implement this in a day or two at most, novices 
  in a couple of weeks with some help in places.</p>
<h2><a name="5"></a>5 Wizard for DataThing construction</h2>
<h3>Background and aim</h3>
<p>The result browser allows users to explore and visualize the contents of a 
  DataThing object, there is, however, no corresponding mechanism for them to 
  construct one. It would be obviously useful for users to be able to enter lists 
  as parameters for workflows, and to import data from other formats such as Excel 
  and simpler ones such as CSV (Comma Seperated Value) and TSV (Tab Seperated 
  Value). This would be coded as a graphical 'wizard' style component to walk 
  a naive user through the process of entering and describing their data.</p>
<h3>Requirements</h3>
<p>To code a graphical wizard, you will need a pretty solid knowledge of Java 
  Swing programming. In addition, the baclava package contains the various classes 
  to do with manipulating and constructing DataThing objects so you'd need to 
  be able to understand and use all the code in there. Some of this code is quite 
  complex, so a reasonable level of familiarity with Java is probably required. 
  The Apache POI project would be a reasonable thing to familiarize yourself with 
  as well if you want to be able to access files in MS' document interchange format 
  such as Excel.</p>
<p>In addition to the technical requirements, you should also solicit the opinions 
  of our users to find out how they would most like to enter their data. A graphical 
  wizard is an exercise in human computer interaction, the human part of this 
  is important!</p>
<h3>Time required</h3>
<p>Probably a couple of weeks, but this depends on how many features you want 
  to include. A basic wizard with no import functionality would be the base case, 
  the import functions may take more or less time depending on how sophisticated 
  you make them. You may require a week or more to get user requirements before 
  coding. </p>
</body>
</html>
