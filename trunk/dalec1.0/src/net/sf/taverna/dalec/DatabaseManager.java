package net.sf.taverna.dalec;

import org.biojava.bio.program.gff.GFFRecord;
import org.biojava.bio.program.gff.GFFEntrySet;
import org.biojava.bio.program.gff.GFFTools;

import java.io.*;
import java.util.*;

import net.sf.taverna.dalec.exceptions.UnableToAccessDatabaseException;

/**
 * Files will be stored in this database as individual flat files, referenced by Filename in the format $STRING_ID$.gff
 * Files are kept in GFF format, requests to this database get back the record as a Biojava GFFRecord object.
 * DatabaseManager is an implementation of runnable.  This means that an instance of DatabaseManager handles the
 * submitting and retrieving of the data to the database, but can also be <code>run</code> to perform these actions
 * automatically within a separate thread.  One file per sequence is held within the database.
 * <p/>
 * A client can either: <il>Call <code>getPendingResults()</code> to retrieve a list of all results yet to be
 * written,</il> <il>Then call </code>writeToFile()</code> to write all pending results to the Database</il> Each method
 * should be invoked in turn.
 * <p/>
 * If a client is to use this "manual" method of writing results to the database, it should be considered that every
 * workflow instance submits its results to DatabaseManager as they are generated, and that these results are retained
 * in memory until written.  Alternatively, an instance of DatabaseManager can be run in a dedicated thread.  In this
 * case, results are handled automatically, and are dynamically written to the database as they are generated.  If there
 * are no pending results, DatabaseManager will wait until new results are submitted.  Otherwise, any instance of this
 * class will run continuously whilst results need to be written to a file.
 *
 * @author Tony Burdett date: 20-Jun-2005
 */
public class DatabaseManager implements Runnable
{
    private File dbLoc;
    private boolean termRequest = false;
    private List resultsToWrite = new ArrayList();
    private List dbListeners = new ArrayList();

    /**
     * Constructor for DatabaseManager.  Simply creates a database home directory if it doesn't already exist.
     *
     * @param databaseLocation
     */
    public DatabaseManager(File databaseLocation)
    {
        this.dbLoc = databaseLocation;
        if (!dbLoc.exists()) dbLoc.mkdirs();
    }

    public void run()
    {
        try
        {
            // continually run as long as thread isn't interrupted
            while (true)
            {
                // wait if there are no results waiting to be written
                while (resultsToWrite.isEmpty())
                {
                    synchronized (resultsToWrite)
                    {
                        resultsToWrite.wait();
                    }
                }
                // Otherwise, grab the pending results and write them to a file
                writeToFile(getPendingResults());
            }
        }
        catch (InterruptedException e)
        {
            // Thread will normally run indefinitely unless interrupted

            // It is possible to request interruption of this DatabaseManager by calling haltActivity
            if (termRequest)
            {
                // Thread has been stopped on request, so do nothing except set termRequest back to false;
                termRequest = false;
            }
            else
            {
                // Some other scenario has caused this thread to terminate, attempt to restart?
                DalecManager.logError(dbLoc, "Database was interrupted abnormally whilst running", e);
            }
        }
    }

    public synchronized void haltActivity()
    {
        termRequest = true;
        Thread.currentThread().interrupt();
    }

    /**
     * Simple method used to append new results, as they are generated, to the end of the pending queue.  Results will
     * be written to the database in the order in which they are generated, and stored in a buffer until they can be
     * written.
     *
     * @param result The Map object representing the result as generated by the implicit Taverna workflow.
     */
    public void addNewResult(GFFRecord result)
    {
        //TODO - this assumes workflow output will be a single GFFRecord (entry set better???) - might need to parse workflow output
        synchronized (resultsToWrite)
        {
            resultsToWrite.add(result);
            resultsToWrite.notifyAll();
        }
    }

    /**
     * Returns <code>true</code> if the file already exists within the database, <code>false</code> otherwise.  Note
     * that this method will not check jobs which are in the queue to be calculated, or those which are currently being
     * evaluated by the workflow.  It is safe to submit any job which is not in the database - if the job is already
     * being computed, DalecManager will notify the client when a new repeated job is submitted.
     *
     * @param seqID
     * @return boolean true if file exists, false otherwise
     */
    public synchronized boolean fileExists(String seqID)
    {
        // This assumes files will be stored in a database by using the format "seqID.gff" - should be fine
        File seqFile = new File(dbLoc, seqID + ".gff");
        if (seqFile.exists())
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /**
     * This method returns the Biojava object <code>GFFEntrySet</code> represented by this GFF file within the database.
     * Calling classes should handle the extraction of sequence or annotation data from the <oode>GFFEntrySet</code>
     *
     * @param seqID
     * @return GFFEntrySet the data held within the GFF file in biojava <code>GFFEntrySet</code> form
     * @throws UnableToAccessDatabaseException
     *
     */
    public synchronized GFFEntrySet getGFFEntry(String seqID) throws UnableToAccessDatabaseException
    {
        try
        {
            GFFEntrySet gffe = GFFTools.readGFF(new File(dbLoc, seqID + ".gff"));
            return gffe;
        }
        catch (Exception e)
        {
            throw new UnableToAccessDatabaseException("Unable to read GFF file from database", e);
        }
    }

    /**
     * Add a <code>DatabaseListener</code> to this database.  There is no limit on the number of listeners which can be
     * registered to one database.
     *
     * @param listener a DatabaseListener
     */
    public void addDatabaseListener(DatabaseListener listener)
    {
        dbListeners.add(listener);
    }

    /**
     * Returns a list of <code>DatabaseListeners</code> registered to this DatabaseManager
     *
     * @return
     */
    public List getDatabaseListener()
    {
        return dbListeners;
    }

    /**
     * Returns a List of biojava <code>GFFRecords</code> rwepresenting all those records which have <i>yet to</i> be
     * written to the database - they are held in an in-memory cache until they are written to disk.
     *
     * @return List pending results - those which have not yet been written to disk.
     */
    public List getPendingResults()
    {
        synchronized (resultsToWrite)
        {
            List results = new ArrayList(resultsToWrite);
            resultsToWrite.clear();
            return results;
        }
    }

    /**
     * Returns a file representing the path to the home directory of the database
     *
     * @return File Database Location
     */
    public File getDatabaseLocation()
    {
        return dbLoc;
    }

    /**
     * This method writes all pending results (ie. those which are returned by calling <code>getPendingResults</code>)
     * to disk.  This would normally be called automatically by the run method of an instance of this class, provided it
     * has been Thread.start() has been called.  If not, or if this approach is not required, this method can be called
     * manually.
     *
     * @param results A list of results which should be written to disk
     */
    public synchronized void writeToFile(List results)
    {
        Iterator it = results.iterator();

        // write the captured results to a file in GFF format, in the appropriate DB location
        while (it.hasNext())
        {
            // TODO - check if this file already exists?
            // Shouldn't be possible, as workflow wouldn't have beed executed if file existed already

            // Convert this GFF record into a GFF entry set ready to be written to file
            GFFRecord record = (GFFRecord) it.next();
            GFFEntrySet gffFileToWrite = new GFFEntrySet();
            gffFileToWrite.add(record);

            // write the entry set to a file
            try
            {
                GFFTools.writeGFF(new File(dbLoc, record.getSeqName() + ".gff"), gffFileToWrite);
                // Once this file has been written, notify all listeners of a new entry
                Iterator jt = dbListeners.iterator();
                while (jt.hasNext())
                {
                    ((DatabaseListener) jt.next()).databaseEntryCreated(record.getSeqName());
                }
            }
            catch (IOException e)
            {
                // notify listener that an entry failed as IO exception occured, then continue
                Iterator jt = dbListeners.iterator();
                while (jt.hasNext())
                {
                    ((DatabaseListener) jt.next()).databaseEntryFailed(record.getSeqName(), e);
                }
            }
        }
    }
}