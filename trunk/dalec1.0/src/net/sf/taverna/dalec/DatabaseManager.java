package net.sf.taverna.dalec;

import org.biojava.bio.program.gff.GFFRecord;
import org.biojava.bio.program.gff.GFFEntrySet;
import org.biojava.bio.program.gff.GFFTools;

import java.io.*;
import java.util.*;

import net.sf.taverna.dalec.exceptions.DatabaseAccessException;

/**
 * Files will be stored in this database as individual flat files, referenced by Filename in the format [String_ID].gff
 * Files are kept in GFF format, requests to this database get back the record as a Biojava GFFRecord object.
 * DatabaseManager is an implementation of runnable.  This means that an instance of DatabaseManager handles the
 * submitting and retrieving of the data to the database, but can also be <code>run</code> to perform these actions
 * automatically within a separate thread.  A client can either: <il>Call <code>getPendingResults()</code> to retrieve a
 * list of all results yet to be written,</il> <il>Then call </code>writeToFile()</code> to write all pending results to
 * the Database</il> Each method should be invoked in turn.  If a client is to use this "manual" method of writing
 * results to the database, it should be considered that every workflow instance submits its results to DatabaseManager
 * as they are generated, and that these results are retained in memory until written.  Alternatively, an instance of
 * DatabaseManager can be run in a dedicated thread.  In this case, results are handled automatically, and are
 * dynamically written to the database as they are generated.  If there are no pending results, DatabaseManager will
 * wait until new results are submitted.  Otherwise, any instance of this class will run continuously whilst results
 * need to be written to a file.
 *
 * @author Tony Burdett date: 20-Jun-2005
 */
public class DatabaseManager implements Runnable
{
    private File dbLoc;
    private List resultsToWrite = new ArrayList();
    private List dbListeners = new ArrayList();

    public DatabaseManager(File databaseLocation)
    {
        this.dbLoc = databaseLocation;
    }

    public void run()
    {
        try
        {
            // continually run as long as thread isn't interrupted
            while (true)
            {
                // wait if there are no results waiting to be written
                while (resultsToWrite.isEmpty())
                {
                    synchronized (resultsToWrite)
                    {
                        resultsToWrite.wait();
                    }
                }
                // Otherwise, grab the pending results and write them to a file
                writeToFile(getPendingResults());
            }
        }
        catch (InterruptedException e)
        {
            // Thread will normally run indefinitely unless interrupted,
            // so if thread is interrupted, do nothing
        }
    }

    /**
     * Simple method used to append new results, as they are generated, to the end of the pending queue.  Results will
     * be written to the database in the order in which they are generated, and stored in a buffer until they can be
     * written.
     *
     * @param result The Map object representing the result as generated by the implicit Taverna workflow.
     */
    public void addNewResult(GFFRecord result)
    {
        //TODO - this assumes workflow output will be a single GFFRecord (entry set better???)
        synchronized (resultsToWrite)
        {
            resultsToWrite.add(result);
            resultsToWrite.notifyAll();
        }
    }

    /**
     * Returns <code>true</code> if the file already exists within the database, <code>false</code> otherwise.  Note
     * that this method will not check jobs which are in the queue to be calculated, or those which are currently being
     * evaluated by the workflow.  It is safe to submit any job which is not in the database - if the job is already
     * being computed, DalecManager will notify the client when a new repeated job is submitted.
     *
     * @param seqID
     * @return boolean true if file exists, false otherwise
     */
    public synchronized boolean fileExists(String seqID)
    {
        // This assumes files will be stored in a database by using the format "seqID.gff" - should be fine
        File seqFile = new File(dbLoc, seqID + ".gff");
        if (seqFile.exists())
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    public synchronized GFFEntrySet getGFFEntry(String seqID) throws DatabaseAccessException
    {
        try
        {
            GFFEntrySet gffe = GFFTools.readGFF(new File(dbLoc, seqID + ".gff"));
            return gffe;
        }
        catch (Exception e)
        {
            throw new DatabaseAccessException("Unable to read GFF file from database", e);
        }
    }

    public void addDatabaseListener(DatabaseListener listener)
    {
        dbListeners.add(listener);
    }

    public List getPendingResults()
    {
        synchronized (resultsToWrite)
        {
            List results = new ArrayList(resultsToWrite);
            resultsToWrite.clear();
            return results;
        }
    }

    public synchronized void writeToFile(List results)
    {
        Iterator it = results.iterator();

        // write the captured results to a file in GFF format, in the appropriate DB location
        while (it.hasNext())
        {
            // TODO - check if this file already exists?
            // Shouldn't be possible, as workflow wouldn't have beed executed if file existed already

            // Convert this GFF record into a GFF entry set ready to be written to file
            GFFRecord record = (GFFRecord) it.next();
            GFFEntrySet gffFileToWrite = new GFFEntrySet();
            gffFileToWrite.add(record);

            // write the entry set to a file
            try
            {
                if (!dbLoc.exists()) dbLoc.mkdirs();
                GFFTools.writeGFF(new File(dbLoc, record.getSeqName() + ".gff"), gffFileToWrite);
                // Once this file has been written, notify all listeners of a new entry
                Iterator jt = dbListeners.iterator();
                while (jt.hasNext())
                {
                    ((DatabaseListener) jt.next()).databaseEntryCreated(record.getSeqName());
                }
            }
            catch (IOException e)
            {
                // write an errorLogEntry if IO error - then continue
                errorLogEntry(record.getSeqName(), e);
            }
        }
    }

    private synchronized void errorLogEntry(String seqID, Throwable e)
    {
        Calendar cal = new GregorianCalendar();
        String date = (cal.get(Calendar.DAY_OF_MONTH) + "-" + (1 + cal.get(Calendar.MONTH)) + "-" + cal.get(Calendar.YEAR));

        File errFile = new File(dbLoc, "." + date);

        try
        {
            if (!dbLoc.exists()) dbLoc.mkdirs();
            PrintWriter errLog = null;
            if (errFile.exists())
            {
                errLog = new PrintWriter(new BufferedWriter(new FileWriter(errFile, true)));
            }
            else
            {
                errLog = new PrintWriter(new BufferedWriter(new FileWriter(errFile)));
            }
            errLog.println("**********Start of log entry**********");
            errLog.println("Error occurred whilst processing sequence " + seqID);
            e.printStackTrace(errLog);
            errLog.println(e.getCause());
            errLog.println("**********End of log entry**********");
        }
        catch (IOException e1)
        {
            e1.printStackTrace();
        }
    }
}