package net.sf.taverna.dalec;

import org.biojava.bio.program.gff.GFFRecord;
import org.biojava.bio.program.gff.GFFEntrySet;
import org.biojava.bio.program.gff.GFFTools;

import java.io.*;
import java.util.*;

/**
 * Files will be stored in this database as individual flat files, referenced by Filename in the format [String_ID].gff
 * Files are kept in GFF format, requests to this database get back the record as a Biojava GFFRecord object.
 *
 * @author Tony Burdett date: 20-Jun-2005
 */
public class DatabaseManager implements Runnable
{
    private File dbLoc;
    private List resultsToWrite = new ArrayList();
    private List dbListeners = new ArrayList();

    public DatabaseManager(File databaseLocation)
    {
        this.dbLoc = databaseLocation;
    }

    public void run()
    {
        try
        {
            // continually grab results to an iterator and send to writeToFile
            while (true)
            {
                // wait if there are no results waiting to be written
                while (resultsToWrite.isEmpty())
                {
                    resultsToWrite.wait();
                }
                // Otherwise, grab the pending results and write them to a file
                writeToFile(getPendingResults());
            }
        }
        catch (InterruptedException e)
        {
            // TODO - exception handling in these cases

        }
    }

    /**
     * Simple method used to append new results, as they are generated, to the end of the pending queue.  Results will
     * be written to the database in the order in which they are generated, and stored in a buffer until they can be
     * written.
     *
     * @param result The Map object representing the result as generated by the implicit Taverna workflow.
     */
    public void addNewResult(GFFRecord result)
    {
        synchronized (resultsToWrite)
        {
            resultsToWrite.add(result);
            resultsToWrite.notifyAll();
        }
    }

    /**
     * Returns <code>true</code> if the file already exists within the database, <code>false</code> otherwise.  Note
     * that this method will not check jobs which are in the queue to be calculated, or those which are currently being
     * evaluated by the workflow.  It is safe to submit any job which is not in the database - if the job is already
     * being computed, DalecManager will notify the client when a new repeated job is submitted.
     *
     * @param seqID
     * @return boolean true if file exists, false otherwise
     */
    public synchronized boolean fileExists(String seqID)
    {
        // This assumes files will be stored in a database by using the format "seqID.gff" - should be fine
        File seqFile = new File(dbLoc, seqID + ".gff");
        if (seqFile.exists())
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    public synchronized GFFRecord getRecord(String seqID)
    {
        return null;
    }

    public void addDatabaseListener(DatabaseListener listener)
    {
        dbListeners.add(listener);
    }

    private List getPendingResults()
    {
        synchronized (resultsToWrite)
        {
            List results = new ArrayList();
            results = resultsToWrite;
            resultsToWrite.clear();
            return results;
        }
    }

    private synchronized void writeToFile(List results)
    {
        Iterator it = results.iterator();

        // write the captured results to a file in GFF format, in the appropriate DB location
        while (it.hasNext())
        {
            // Convert this GFF record into a GFF entry set ready to be written to file
            GFFRecord record = (GFFRecord) it.next();
            GFFEntrySet gffFileToWrite = new GFFEntrySet();
            gffFileToWrite.add(record);

            // write the entry set to a file
            try
            {
                GFFTools.writeGFF(dbLoc.getAbsolutePath() + record.getSeqName() + ".gff", gffFileToWrite);
                // Once this file has been written, notify all listeners of a new entry
                Iterator jt = dbListeners.iterator();
                while (jt.hasNext())
                {
                    ((DatabaseListener) jt.next()).databaseEntryCreated(record.getSeqName());
                }
            }
            catch (IOException e)
            {
                // write an errorLogEntry if IO error - then continue
                errorLogEntry(record.getSeqName(), e);
            }
        }
    }

    private synchronized void errorLogEntry(String seqID, Throwable e)
    {
        Calendar cal = new GregorianCalendar();
        String date = (cal.get(Calendar.DAY_OF_MONTH) + "-" + (1 + cal.get(Calendar.MONTH)) + "-" + cal.get(Calendar.YEAR));

        File errFile = new File(dbLoc, "." + date);

        try
        {
            PrintWriter errLog = null;
            if (errFile.exists())
            {
                errLog = new PrintWriter(new BufferedWriter(new FileWriter(errFile, true)));
            }
            else
            {
                errLog = new PrintWriter(new BufferedWriter(new FileWriter(errFile)));
            }
            errLog.println("**********Start of log entry**********");
            errLog.println("Error occurred whilst processing sequence " + seqID);
            e.printStackTrace(errLog);
            errLog.println(e.getCause());
            errLog.println("**********End of log entry**********");
        }
        catch (IOException e1)
        {
            e1.printStackTrace();
        }
    }
}