<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Entity Building and Data Management in the T2 Plugin</title>

  <section>
    <title>Data Management Basics</title>

    <para>The Data Manager is a file based storage system which for this
    plugin stores data to a user specified area (default is
    taverna.home/t2_datamanager). Each time the plugin is instantiated it
    generates a unique identifier (UUID based) for the data manager namespace
    and the data manager then creates this directory. For example, the default
    would be (on a Mac) /Users/Ian/Library/Application
    Support/Taverna-1.7.0/t2_datamanager/f623737b-6f26-4449-9853-ed6599ca816b.
    A data manager also has an associated Blob Store for the storage of binary
    data. Each data manager can also handle data for a series of Locational
    Contexts (eg, localhost, subnet etc..) but this is not implemented in this
    release. In the full T2 system there will be many data managers in a
    peer-to-peer fabric which will co-operate to dereference data using this
    namespace and context information. The data which the data manager is
    handling is serialised and stored in XML format in files in directories
    appropriate to their type: blob for binary, ddoc for Data Documents, list
    for lists and error for errors. Each of these serialised files also has a
    unique identifier and are stored in sub-directories according to their
    first two characters. eg.
    t2-datamanager/e53b2231-d247-420f-8437-570d40e0163c/ddoc/2f/2fcf35de-3b87-48b9-be19-853819a25910.xml</para>

    <para>T2 uses the concept of Entities for the storage, retrieval and
    passing around of data references. It should be noted that T2 tries to
    avoid storing data whenever it can and it is only in the case of binary
    objects that the actual data would be stored. There are four types of
    Entities: List, Literal, Data Document and Error Document. These Entities
    require identitfiers. These identifiers are specific to each type of
    Entity and take the form of a URI. Example identifiers are below: List
    urn:t2data:list://e53b2231-d247-420f-8437-570d40e0163c/0afe5967-310d-40c1-bc54-96bc790c4578/1
    Literal urn:t2data:literal://string.literal/jhfjhfjhf Data Document
    urn:t2data:ddoc://e53b2231-d247-420f-8437-570d40e0163c/2fcf35de-3b87-48b9-be19-853819a25910
    Error Document
    urn:t2data:error://e53b2231-d247-420f-8437-570d40e0163c/error1/3/2 In this
    case, e53b2231-d247-420f-8437-570d40e0163c is the namespace which the data
    manager is handling.</para>
  </section>

  <section>
    <title>Using Data in Workflows</title>

    <para>If you have some data which you want to use in a workflow you have
    to register it with a data manager. In return you get a unique Entity
    Identitfier. Literals, Lists, Data Documents and Errors can all be
    registered in this way. In the case of a List you would have to register
    all the Entities which it contains before registering the actual list. All
    this registering can be time consuming so there is another way - the Data
    Facade. Using this facade allows you to register an Object (in Java terms)
    and lets the software to do the hard work of working out what it is and
    registering it for you. This will work for Literals (String, Int, Double,
    Float, boolean, Long), Byte Arrays and Input Streams (for blobs) and
    Arrays. For Reference Scheme data (File and Http currently) you must
    register it directly with a data manager since only you will know where
    your data is. When you have, for example, a File which you want to use in
    your workflow you must first create the Reference Scheme(s) which explain
    how to get to it. This set of references can then be registered with the
    data manager of your choice. As stated earlier, except for binary style
    blobs, the data itself is not stored in the data manager but only the
    references to it. These references to a piece of data are stored in a Data
    Document. The references (more correctly Reference Schemes) explain how to
    get to the data itself. In the current implementation there are Reference
    Schemes for Files, Http and Blobs (even though we have the blobs on disk,
    the data manager still has to know how to get to the correct one). We get
    the actual data by dereferencing a scheme using a data manager. In
    general, Literals are not stored since their value is contained inside
    their identifier although if they are contained in a List then their
    Identifier (which is also the Entity!!) will be serialised within it.
    However, in the case of a String Literal it will be stored as a blob if it
    is greater than 80 characters long. In this case you will receive a Data
    Document containing a Blob Reference Scheme when you store the
    string.</para>
  </section>

  <section>
    <title>Data Serialisation</title>

    <para>The Data Manager currently uses JAXB for serialisation of Entitites.
    In order to serialise an Entity it implements the beanable interface
    (net.sf.taverna.t2.util.beanable.Beanable). This interface is
    parameterised on the bean type The Beanable interface forces an entity to
    implement the getAsBean and setAsBean methods. This requires a Bean (a
    simple class with a no parameter constructor and get/sets for its fields
    eg. net.sf.taverna.t2.cloudone.bean.DataDocumentBean) to get and set. It
    also requires a factory to associate the Beanable entity with the Bean
    type so that when serialising/de-serialising the correct entity bean type
    is stored/retrieved. An example factory is
    net.sf.taverna.t2.cloudone.refscheme.FileRefSchemeFactory. So that JAXB
    knows how to serialise the beans they require annotations on the class.
    For example for FileReferenceBean it has @XmlRootElement(namespace =
    "http://taverna.sf.net/t2/cloudone/refscheme/file/", name =
    "fileReferenceScheme"). This also allows you to customise how fields are
    referred to when serialised (eg. DataDocumentBean has @XmlElement(name =
    "reference") above the getReferences method). The SPI lookup to find these
    factories is in:
    META-INF/services/net.sf.taverna.t2.util.beanable.BeanableFactory. Within
    this file you should have a reference to the factory for the beanable
    type. This SPI extension also allows you to define your own reference
    schemes and have full serialisation support. The example below shows the
    different classes/files needed for FileReferenceScheme. Class -
    FileReferenceScheme (which implements
    ReferenceScheme&lt;FileReferenceBean&gt;) Bean - FileReferenceBean Factory
    - FileReferenceSchemeFactory (which extends
    BeanableFactory&lt;FileReferenceScheme, FileReferenceBean&gt;) SPI -
    cloudone-impl/src/main/resources/META-INF/services/net.sf.taverna.t2.util.beanable.BeanableFactory
    (which contains the line
    net.sf.taverna.t2.cloudone.refscheme.file.FileReferenceSchemeFactory)</para>
  </section>
</chapter>