/*
 * Copyright (C) 2003 The University of Manchester 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 *
 ****************************************************************
 * Source code information
 * -----------------------
 * Filename           $RCSfile: XMLSplitterSerialisationHelper.java,v $
 * Revision           $Revision: 1.1 $
 * Release status     $State: Exp $
 * Last modified on   $Date: 2006-05-17 14:33:01 $
 *               by   $Author: sowen70 $
 * Created on 16-May-2006
 *****************************************************************/
package org.embl.ebi.escience.scuflworkers.java;

import java.util.Iterator;

import org.embl.ebi.escience.scufl.XScufl;
import org.embl.ebi.escience.scuflworkers.wsdl.parser.ArrayTypeDescriptor;
import org.embl.ebi.escience.scuflworkers.wsdl.parser.BaseTypeDescriptor;
import org.embl.ebi.escience.scuflworkers.wsdl.parser.ComplexTypeDescriptor;
import org.embl.ebi.escience.scuflworkers.wsdl.parser.TypeDescriptor;
import org.jdom.Element;

/**
 * A helper class that supports the XMLOutputSplitter and XMLInputSplitter, providing
 * the ability for each to be serialised/deserialised to and from the extensions XML for the ScuflModel XML
 * when storing a workflow. This XML describes the TypeDescriptor tree that the Splitter wraps.
 * @author sowen
 *
 */
public class XMLSplitterSerialisationHelper {

	/**
	 * Generates the extensions XML that describes the TypeDescriptor to allow
	 * an XMLInputSplitter or XMLOutputSplitter to be reconstructed using
	 * consumeXML.
	 */
	public static Element typeDescriptorToExtensionXML(TypeDescriptor descriptor) {
		Element result = new Element("extensions", XScufl.XScuflNS);
		Element type = null;
		if (descriptor instanceof ComplexTypeDescriptor)
			type = constructElementForComplexType((ComplexTypeDescriptor) descriptor);
		else if (descriptor instanceof ArrayTypeDescriptor)
			type = constructElementForArrayType((ArrayTypeDescriptor) descriptor);
		result.addContent(type);
		return result;
	}

	/**
	 * Generates the TypeDescriptor structurefrom the extensions XML element
	 * provided. This assumes that the root of the structure is <complextype/>.
	 * This will be the same xml generated by provideXML.
	 */
	public static TypeDescriptor extensionXMLToTypeDescriptor(Element element) {
		Element child = (Element) element.getChildren().get(0);
		return buildTypeDescriptorFromElement(child);
	}

	private static Element constructElementForArrayType(ArrayTypeDescriptor descriptor) {
		Element result = new Element("arraytype", XScufl.XScuflNS);
		populateElement(result, descriptor);
		Element elementType = new Element("elementtype", XScufl.XScuflNS);
		if (descriptor.getElementType() instanceof ComplexTypeDescriptor) {
			elementType.addContent(constructElementForComplexType((ComplexTypeDescriptor) descriptor.getElementType()));
		} else if (descriptor.getElementType() instanceof ArrayTypeDescriptor) {
			elementType.addContent(constructElementForArrayType((ArrayTypeDescriptor) descriptor.getElementType()));
		} else if (descriptor.getElementType() instanceof BaseTypeDescriptor) {
			Element element = new Element("basetype", XScufl.XScuflNS);
			populateElement(element, descriptor.getElementType());
			elementType.addContent(element);
		}
		result.addContent(elementType);
		return result;
	}

	private static Element constructElementForComplexType(ComplexTypeDescriptor descriptor) {
		Element result = new Element("complextype", XScufl.XScuflNS);
		populateElement(result, descriptor);
		Element elements = new Element("elements", XScufl.XScuflNS);
		for (Iterator iterator = descriptor.getElements().iterator(); iterator.hasNext();) {
			TypeDescriptor desc = (TypeDescriptor) iterator.next();
			Element element = null;
			if (desc instanceof ComplexTypeDescriptor) {
				element = constructElementForComplexType((ComplexTypeDescriptor) desc);
			} else if (desc instanceof ArrayTypeDescriptor) {
				element = constructElementForArrayType((ArrayTypeDescriptor) desc);
			} else if (desc instanceof BaseTypeDescriptor) {
				element = new Element("basetype", XScufl.XScuflNS);
				populateElement(element, desc);
			}
			if (element != null)
				elements.addContent(element);
		}
		result.addContent(elements);
		return result;
	}

	private static void populateElement(Element element, TypeDescriptor descriptor) {
		element.setAttribute("optional", String.valueOf(descriptor.isOptional()));
		element.setAttribute("unbounded", String.valueOf(descriptor.isUnbounded()));
		element.setAttribute("typename", descriptor.getType());
		element.setAttribute("name", descriptor.getName() == null ? "" : descriptor.getName());
	}

	private static TypeDescriptor buildTypeDescriptorFromElement(Element element) {
		TypeDescriptor result = null;

		if (element.getName().equalsIgnoreCase("complextype")) {
			ComplexTypeDescriptor desc = new ComplexTypeDescriptor();
			Element elements = element.getChild("elements", XScufl.XScuflNS);
			for (Iterator iterator = elements.getChildren().iterator(); iterator.hasNext();) {
				Element childElement = (Element) iterator.next();
				desc.getElements().add(buildTypeDescriptorFromElement(childElement));
			}
			result = desc;
		} else if (element.getName().equalsIgnoreCase("arraytype")) {
			result = new ArrayTypeDescriptor();
			Element elementType = element.getChild("elementtype", XScufl.XScuflNS);
			((ArrayTypeDescriptor) result).setElementType(buildTypeDescriptorFromElement((Element) elementType
					.getChildren().get(0)));
		} else if (element.getName().equalsIgnoreCase("basetype")) {
			result = new BaseTypeDescriptor();

		}

		result.setName(element.getAttributeValue("name"));
		result.setType(element.getAttributeValue("typename"));
		result.setOptional(element.getAttributeValue("optional").equalsIgnoreCase("true"));
		result.setUnbounded(element.getAttributeValue("unbounded").equalsIgnoreCase("true"));
		return result;
	}
}
