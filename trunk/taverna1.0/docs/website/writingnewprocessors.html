<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
body {
	font-family: Arial, Helvetica, sans-serif;
	text-align: justify;
}
h4 {

	font-family: Arial, Helvetica, sans-serif;
	font-size: x-small;
	font-style: normal;
	font-weight: bold;
	font-variant: normal;
	
	text-transform: capitalize;
	color: #000000;
}
-->
</style>
<link href="styles.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1>Writing new processor types for Taverna</h1>
<p>Tom Oinn, <a href="mailto:tmo@ebi.ac.uk">tmo@ebi.ac.uk</a>, 13<sup>th</sup> 
  January 2004</p>
<p>This document describes the steps required to implement and register a completely 
  new processor type with Taverna and the enactor.</p>
<blockquote> 
  <p>There are a number of different classes comprising a processor implementation. 
    These classes handle the construction of new processors within the workflow 
    model, the invocation of the underlying logic, the locations and configuration 
    of instances of the processor type and the serialization and deserialization 
    to and from an XML form required to load and save workflow definitions using 
    the processor. Associated with these classes is a properties file which contains 
    the information Taverna's runtime requires to locate the classes and map them 
    to appropriate entities within the workflow.</p>
  <p>All the default implementations of these classes, for example the WSDL based 
    processor, are contained within the org.embl.ebi.escience.scuflworkers package, 
    and it is strongly advised that you read this guide while examining that package 
    and its subpackages for examples, it will hopefully make things a bit clearer.</p>
</blockquote>
<h2>Implementation classes</h2>
<h3>Processor</h3>
<blockquote>
  <p>The processor class has the role of representing the processor functionality 
    within the workflow model. It is a subclass of the org.embl.ebi.escience.scufl.Processor 
    class. It is worth noting that the logic required to invoke the operation 
    that this processor describes is not contained within this class. Instead, 
    the class mainly has the role of creating appropriate input and output Port 
    objects when it is itself created. For example, the WSDLBasedProcessor inspects 
    a WSDL document, locates the appropriate operation, reads the message parts 
    from this, inspects their types and names and constructs Port objects appropriately, 
    setting their syntactic types according to the types defined in the WSDL. 
    The simplest example of a Processor implementation is the StringConstantProcessor, 
    which creates a single output port with type 'text/plain', more complex ones 
    are the WSDLBasedProcessor mentioned above and the SoaplabProcessor, which 
    uses web service calls to determine what Port objects are required.</p>
  <p>Where a Processor implementation has configuration data, for example the 
    URL for a WSDL document, it is suggested that these data be made available 
    in the normal fashion for Java beans.</p>
</blockquote>
<h3>XML Handler</h3>
<blockquote>
  <p>The XML handler performs serialization of a Processor implementation to XML, 
    and the corresponding construction of a Processor implementation from the 
    XML fragment. When serializing the Processor, only the minimum state required 
    to reconstruct that Processor should be stored. The class is responsible for 
    everything within the 'spec' block in the XML definition, see the various 
    extant handler classes for examples of this. If an appropriate XML handler 
    is not registered then Taverna will not be able to load or store workflow 
    definitions containing references to this processor type.</p>
</blockquote>
<h3>ProcessorFactory</h3>
<blockquote>
  <p>The ProcessorFactory exposes a standard interface to allow the construction 
    of a Processor implementation. For processor types that require significant 
    configuration, the configuration options are passed to the constructor of 
    the ProcessorFactory. This is as close as Java gets to curried functions, 
    effectively you configure a ProcessorFactory which returns a ProcessorFactory 
    instance that in turn constructs Processor implementations when supplied with 
    a name and workflow model. These classes are normally contained within Scavenger 
    nodes as the user object, the mouse listener on the JTree that the Scavenger 
    objects are contained within detects the ProcessorFactory and exposes a simple 
    dialog to the user requesting a name for the new processor. See the WSDLBasedProcessorFactory 
    for an example.</p>
</blockquote>
<h3>Scavenger</h3>
<blockquote>
  <p>The scavenger class, if present, allows the processor to appear in the service 
    selection panel. It is a subclass of org.embl.ebi.escience.scuflui.workbench.Scavenger, 
    which in turn is a subclass of DefaultMutableTreeNode. This is the class that 
    is added to the service selection panel's JTree, if any node of the JTree 
    contains a ProcessorFactory subclass then a menu will be created to allow 
    a new instance of the appropriate service to be constructed. Scavengers always 
    contain fully configured factory instances, so the StringConstantScavenger 
    creates StringConstantProcessor nodes without any further parameters, leaving 
    the configuration of the processor in the workflow up to other classes. Where 
    there is a need to supply parameters to a scavenger, the ScavengerHelper class 
    is used.</p>
</blockquote>
<h3>ScavengerHelper (optional)</h3>
<blockquote>
  <p>The ScavengerHelper class is used whenever there is a requirement to pass 
    configuration information to the service selection panel. For example, when 
    adding a new WSDLScavenger (a node in the JTree that shows the available operations 
    and types within a web service), the user must enter a URL to the WSDL document. 
    To allow for this, classes that implement the ScavengerHelper interface must 
    implement a method to return an ActionListener that is called when the user 
    selects the scavenger from the menu on the service selection panel. See the 
    WSDLScavengerHelper for an example of this.</p>
</blockquote>
<h3>ProcessorTask</h3>
<blockquote>
  <p>The ProcessorTask subclass performs the actual invocation logic of the processor. 
    It contains a single execute method that takes a Map and returns a Map, in 
    both cases the Map has string keys corresponding to the names of input and 
    output ports respectively, and values containing DataThing objects which wrap 
    the actual input and output data. A simple example of this class is the StringConstantTask. 
    In addition, this class is currently responsible for generating provenance 
    blocks, although this is due for replacement and so can safely be ignored 
    at present. In all probability.</p>
</blockquote>
<h3>Editor (optional)</h3>
<blockquote>
  <p>If the processor type you are implementing can be edited once it has been 
    instantiated then you may define an editor class. This class should implement 
    the ProcessorEditor interface, which mandates a method that returns an ActionListener 
    and one that returns a description of the editor. The ActionListener is attached 
    to a menu item in the context menu of all processors of this type within the 
    Scufl Model explorer panel, this allows you to create whatever approprate 
    gui components you wish when the user chooses to invoke the editor. An example 
    of this functionality is the StringConstantEditor, which allows the user to 
    change the string emited by the StringConstant processor.</p>
</blockquote>
<h2>Registering the classes with Taverna</h2>
<h3>Registering the processor type</h3>
<blockquote>
  <p>In order to tell Taverna about the above classes you need to add various 
    lines to a taverna.properties. I say 'a' rather than 'the' because if there 
    is more than one file with this name at the root of the class path all such 
    files will be merged. This allows third parties to extend Taverna without 
    adding their code to our codebase, if the above classes and the properties 
    file are placed in a seperate .jar file and added to the classpath Taverna 
    should pick up the extra functionality automatically. An example of a registration 
    section is shown below:</p>
  <pre>   taverna.processor.stringconstant.class = org.embl.ebi.escience.scuflworkers.stringconstant.StringConstantProcessor
   taverna.processor.stringconstant.xml = org.embl.ebi.escience.scuflworkers.stringconstant.StringConstantXMLHandler
   taverna.processor.stringconstant.colour = lightsteelblue
   taverna.processor.stringconstant.icon = org/embl/ebi/escience/scuflui/stringconstant.gif
   taverna.processor.stringconstant.taskclass = org.embl.ebi.escience.scuflworkers.stringconstant.StringConstantTask
   taverna.processor.stringconstant.editor = org.embl.ebi.escience.scuflworkers.stringconstant.StringConstantEditor</pre>
  <p>The first line registers the Processor implementation. The third token in 
    the key, in this case 'stringconstant' should be the same as the value of 
    the spec XML element, so in this case if Taverna finds a block that looks 
    like the following it will try to use these registered classes to instantiate 
    the processor.</p>
  <pre>   &lt;processor name=&quot;foo&quot;&gt;
     &lt;stringconstant&gt;....&lt;/stringconstant&gt;
   &lt;/processor&gt;
</pre>
  <p>The second line registers the XML handler classes, as mentioned above these 
    do the actual work of serializing and deserializing the processor to and from 
    XML. The third line is optional, and specifies the colour that should be used 
    to represent the processor in the graphical view. The value of this attribute 
    should be a valid colour as understood by the 'dot' program, a table of all 
    such colours is available <a href="http://www.research.att.com/%7Eerg/graphviz/info/colors.html">here</a>. 
    The fourth line specifies an image to be used as an icon within the service 
    selection panel and workflow explorer views, the value is the resource path 
    assuming that the image is stored within the classpath, normally in the same 
    jar file as the implementation classes. The fifth line contains the class 
    of the ProcessorTask implementation, and is required for the processor to 
    be invoked (but not for any editing purpose), and the final line optionally 
    specifies a customizer widget for the processor, allowing for in place editing 
    of parameters. In the case of the StringConstantProcessor, for example, this 
    editor allows the user to change the string emited by the processor.</p>
</blockquote>
<h3>Registering scavengers</h3>
<blockquote> 
  <p>Additional lines are added to the taverna.properties file to register Scavenger 
    or ScavengerHelper classes. These are both registered with the same syntax, 
    the system detects which type of class it is and behaves appropriately.</p>
  <h4>ScavengerHelper classes</h4>
  <p>If the class registered is a ScavengerHelper implementation, a new item is 
    added to the context menu of the service selection panel, and the ActionListener 
    created by the ScavengerHelper is bound to this menu item. This is used by 
    the WSDL and Soaplab processor types, as both these require configuration 
    information before they can create the scavenger tree.</p>
  <h4>Scavenger classes</h4>
  <p>If the class is a Scavenger then it is constructed and added directly to 
    the service selection tree whenever a new service selection panel is created. 
    This is used, for example, by the stringconstant and local processor types.</p>
  <p>The section of the properties file containing the scavenger and scavengerhelper 
    classes supplied with the default Taverna build is shown below:</p>
  <pre>   taverna.scavenger.org.embl.ebi.escience.scuflworkers.soaplab.SoaplabScavengerHelper    = soaplabwsdl
   taverna.scavenger.org.embl.ebi.escience.scuflworkers.wsdl.WSDLScavengerHelper    = arbitrarywsdl
   taverna.scavenger.org.embl.ebi.escience.scuflworkers.talisman.TalismanScavengerHelper    = talisman
   taverna.scavenger.org.embl.ebi.escience.scuflworkers.workflow.WorkflowScavengerHelper    = workflow
   taverna.scavenger.org.embl.ebi.escience.scuflworkers.stringconstant.StringConstantScavenger    = stringconstant
   taverna.scavenger.org.embl.ebi.escience.scuflworkers.java.LocalServiceScavenger    = local
 </pre>
  <p>The key for the properties is constructed from the string 'taverna.scavenger.' 
    with the full class name of the scavenger or scavengerhelper class appended, 
    the value being the tag name corresponding to the type of processor that this 
    scavenger will eventually create. This is to allow multiple scavengers for 
    the same type of processor, for example a WSDL based scavenger could either 
    have the WSDL location explicitly stated, or could scan some kind of registry 
    - in this case the scavenger implementations would differ but both would produce 
    WSDLBasedProcessor objects.</p>
</blockquote>
<p><a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=74874&type=2" width="125" height="37" border="0" alt="SourceForge.net Logo" /></a></p>
</body>
</html>
