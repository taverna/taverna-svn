package uk.org.taverna.scufl2.api.common;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;

/**
 * A {@link java.util.Set} of {@link Named} {@link WorkflowBean}.
 * <p>
 * This set will guarantee to never contain more than one {@link Named} object per
 * {@link Named#getName()}.
 * <p>
 * It is also possible to retrieve values by name using {@link #getByName(String)}, or remove using
 * {@link #removeByName(String)}. The names can also be found in {@link #getNames()} and
 * {@link #nameIterator()}
 * <p>
 * Internally this set is backed by a {@link TreeMap}.
 * 
 * @author Stian Soiland-Reyes
 * 
 * @param <T>
 *            subclass of {@link Named} to keep in this set.
 */
public class NamedSet<T extends Named> extends AbstractSet<T> implements SortedSet<T> {

	protected transient SortedMap<String, T> namedMap;

	/**
	 * Constructs an empty <code>NamedSet</code>.
	 */
	public NamedSet() {
		namedMap = new TreeMap<String, T>();
	}

	/**
	 * Constructs a <code>NamedSet</code> containing all the elements of the given collection.
	 * <p>
	 * If the collection contains several {@link Named} elements with the same name, only the last
	 * of those elements will be in the new <code>NamedSet</code>.
	 * 
	 * @param collection
	 *            the collection whose elements are to be added to the set
	 */
	public NamedSet(Collection<? extends T> collection) {
		namedMap = new TreeMap<String, T>();
		addAll(collection);
	}

	/**
	 * Adds the {@link Named} {@link WorkflowBean} and returns <code>true</code> iff the set did not
	 * already contain an element with the same name.
	 * 
	 * The element <strong>must not</strong> be <code>null</code>
	 * <p>
	 * If a different (object identity) element with the same name already exists in the set, the
	 * element will be replaced the new element and <code>false</code> will be returned.
	 * <p>
	 * Inserting the same object instance a second time will have no effect.
	 * 
	 * @return <code>true</code> iff the set did not already contain an element with the same name
	 */
	@Override
	public boolean add(T named) {
		return namedMap.put(named.getName(), named) == null;
	}

	/**
	 * Adds the {@link Named} {@link WorkflowBean} with a unique name if the name already exist.
	 * <p>
	 * Similar to {@link #add(Named)}, but if a (object identity) different element with the same
	 * name already exists in the set, the element to be inserted will be given a unique name before
	 * inserting.
	 * <p>
	 * This means that inserting the same object instance a second time will have no effect, as with
	 * {@link #add(Named)}.
	 * <p>
	 * The unique name is generated by appending <code>_x</code> to the existing name, where x is a
	 * number from 2 or higher. An existing numeric prefix will first be removed.
	 * <p>
	 * For example, if the set already contains elements named "fish", "fish_2" and "fish_5", but
	 * you try to insert a different element which is named "fish" or "fish_5", it will be renamed
	 * to "fish_3" before inserting.
	 * <p>
	 * <strong>Note:</strong> If the element is a {@link Child} instance, and it's
	 * {@link Child#getParent()} is not <code>null</code> (or this set) the renaming could
	 * potentially cause a conflict in the old parent set. (In the example above, if the element's
	 * old parent has a child "fish_3" it will be overwritten by this instance).
	 * 
	 * @param element
	 *            the <code>Named WorkflowBean</code> to add
	 * @return the final {@link T#getName()} after insertion
	 */
	public String addWithUniqueName(T element) {
		String name = element.getName();
		T existing = getByName(name);
		if (element == existing) {
			return name;
		}

		// Remove any existing number suffix
		String nameTemplate = name.replaceAll("_\\d+$", "_");

		long i = 1;
		while (getNames().contains(name)) {
			name = nameTemplate + i++;
		}

		element.setName(name);
		add(element);
		return name;
	}

	@Override
	public void clear() {
		namedMap.clear();
	}

	@SuppressWarnings("unchecked")
	@Override
	public NamedSet<T> clone() {
		NamedSet<T> copy;
		try {
			copy = (NamedSet<T>) super.clone();
		} catch (CloneNotSupportedException e) {
			throw new IllegalStateException(e);
		}
		if (!(this.namedMap instanceof TreeMap)) {
			throw new IllegalStateException("Can't clone submap");
		}
		copy.namedMap = (SortedMap<String, T>) ((TreeMap) this.namedMap).clone();
		return copy;
	}

	@Override
	public Comparator<? super T> comparator() {
		return null;
	}

	/**
	 * Return <code>true</code> if the <code>NamedSet</code> contains the given object, as compared
	 * using its {@link Object#equals(Object)} method.
	 * <p>
	 * Note that if a different object with the same name exists, this method will return
	 * <code>false</code>. To check for existence of a name, use {@link #containsName(String)}.
	 * 
	 * @see Collection#contains(Object)
	 * @param o
	 * @return
	 */
	@Override
	public boolean contains(Object o) {
		if (!(o instanceof Named)) {
			return false;
		}
		Named named = (Named) o;
		return named.equals(namedMap.get(named.getName()));
	}

	/**
	 * Return <code>true</code> if the <code>NamedSet</code> contains an element with the given
	 * name.
	 * 
	 * @param name
	 *            the name of object
	 * @return <code>true</code> if an element with given name is in set
	 */
	public boolean containsName(String name) {
		return namedMap.containsKey(name);
	}

	@Override
	public T first() {
		return namedMap.get(namedMap.firstKey());
	}

	/**
	 * Return the element with the given name from the set.
	 * 
	 * Returns <code>null</code> if the set does not contain an element with the given name.
	 * 
	 * @param name
	 *            the name of the element to return
	 * @return the element with the given name from the set
	 */
	public T getByName(String name) {
		return namedMap.get(name);
	}

	/**
	 * Returns a set of the names of the elements in this set.
	 * 
	 * @return a set of the names of the elements in this set
	 */
	public Set<String> getNames() {
		return namedMap.keySet();
	}

	@Override
	public SortedSet<T> headSet(T toElement) {
		// FIXME: Return a view instead of a copy
		NamedSet<T> headSet = new NamedSet<T>();
		headSet.namedMap = namedMap.headMap(toElement.getName());
		return headSet;
	}

	@Override
	public boolean isEmpty() {
		return namedMap.isEmpty();
	}

	@Override
	public Iterator<T> iterator() {
		return namedMap.values().iterator();
	}

	@Override
	public T last() {
		return namedMap.get(namedMap.lastKey());
	}

	public Iterator<String> nameIterator() {
		return namedMap.keySet().iterator();
	}

	@Override
	public boolean remove(Object o) {
		if (!(o instanceof Named)) {
			return false;
		}
		Named named = (Named) o;
		String name = named.getName();
		T exists = namedMap.get(name);
		if (named.equals(exists)) {
			return namedMap.remove(named.getName()) != null;
		}
		return false;
	}

	/**
	 * Removes the element with the given name.
	 * 
	 * Returns the {@link Named} element that was removed or <code>null</code> if the set did not
	 * contain an element with the given name.
	 * 
	 * @param name
	 *            the name of the element to remove
	 * @return the {@link Named} element that was removed or <code>null</code> if the set did not
	 *         contain an element with the given name
	 */
	public T removeByName(String name) {
		return namedMap.remove(name);
	}

	@Override
	public int size() {
		return namedMap.size();
	}

	@Override
	public SortedSet<T> subSet(T fromElement, T toElement) {
		NamedSet<T> headSet = new NamedSet<T>();
		headSet.namedMap = namedMap.subMap(fromElement.getName(), toElement.getName());
		return headSet;
	}

	@Override
	public SortedSet<T> tailSet(T fromElement) {
		NamedSet<T> headSet = new NamedSet<T>();
		headSet.namedMap = namedMap.tailMap(fromElement.getName());
		return headSet;
	}

}
