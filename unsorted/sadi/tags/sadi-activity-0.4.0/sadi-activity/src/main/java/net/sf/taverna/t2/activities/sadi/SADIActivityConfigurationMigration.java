package net.sf.taverna.t2.activities.sadi;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import ca.wilkinsonlab.sadi.SADIException;
import ca.wilkinsonlab.sadi.client.Service;
import ca.wilkinsonlab.sadi.rdfpath.RDFPath;
import ca.wilkinsonlab.sadi.rdfpath.RDFPathElement;
import ca.wilkinsonlab.sadi.utils.LabelUtils;
import ca.wilkinsonlab.sadi.utils.OnymizeUtils;

import com.hp.hpl.jena.rdf.model.ResourceFactory;

/**
 * This class is used to convert a SADIActivityConfigurationBean serialized
 * from an earlier version of the plugin.
 * 
 * @author Luke McCarthy
 */
public class SADIActivityConfigurationMigration
{
	private static final Logger log = Logger.getLogger(SADIActivity.class);
	
	private static final Pattern oldPathPattern = Pattern.compile("(.*) \\((.*?)\\)");
	
	/**
	 * Update in place a SADIActivity whose SADIActivityConfigurationBean 
	 * might have been deserialized from a workflow saved by an older 
	 * version of the plugin.
	 * @param activity the SADIActivity
	 * @throws SADIException
	 */
	public static void updateConfiguration(SADIActivity activity, Service service) throws SADIException
	{
		SADIActivityConfigurationBean config = activity.getConfiguration();
		updateRegistry(config);
		updateConfiguration03xTo04x(config, service);
	}

	/* update obsolete default SADI registries...
	 */
	static void updateRegistry(SADIActivityConfigurationBean config)
	{
		if (StringUtils.equals(config.getGraphName(), "http://sadiframework.org/registry"))
			config.setGraphName("http://sadiframework.org/registry/");
	}

	@SuppressWarnings("deprecation")
	static void updateConfiguration03xTo04x(SADIActivityConfigurationBean config, Service service)
	{
		if (config.getInputPortMap() == null) {
			config.setInputPortMap(new HashMap<String, String>());
			if (config.getInputRestrictionPaths() != null) {
				/* if the port connected to the input class as a whole,
				 * the path will be empty and we need to set the name such
				 * that it will match the old workflow...
				 */
				String defaultPortName = LabelUtils.getDefaultLabel(ResourceFactory.createResource(service.getInputClassURI()));
				convert03xPathListTo04xPathMap(config.getInputRestrictionPaths(), config.getInputPortMap(), defaultPortName);
			}
		}
		if (config.getOutputPortMap() == null) {
			config.setOutputPortMap(new HashMap<String, String>());
			if (config.getOutputRestrictionPaths() != null) {

				/* if the port connected to the input class as a whole,
				 * the path will be empty and we need to set the name such
				 * that it will match the old workflow...
				 */
				String defaultPortName = LabelUtils.getDefaultLabel(ResourceFactory.createResource(service.getOutputClassURI()));
				convert03xPathListTo04xPathMap(config.getOutputRestrictionPaths(), config.getOutputPortMap(), defaultPortName);;
			}
		}
	}

	static void convert03xPathListTo04xPathMap(List<List<String>> oldPathList, Map<String, String> newPathMap, String defaultPortName)
	{
		List<RDFPath> newPaths = new ArrayList<RDFPath>(oldPathList.size());
		for (List<String> oldPath: oldPathList) {
			RDFPath newPath = null;
			try {
				newPath = convert03xStringPathToRDFPath(oldPath);
			} catch (Exception e) {
				log.error(String.format("error converting port specification %s", oldPath), e);
			}
			if (newPath != null) {
				newPaths.add(newPath);
			}
		}
		/* port names have to match those that would have been generated by
		 * the old plugin; i.e.: "property (class)" or "property (class) #"
		 */
		for (RDFPath path: newPaths) {
			RDFPathElement element = path.getLastPathElement();
			String name;
			if (element == null) {
				name = defaultPortName;
			} else if (element.getType() != null) {
				name = String.format("%s (%s)", 
						element.getProperty().getLocalName(), 
						element.getType().getLocalName());
			} else {
				name = element.getProperty().getLocalName();
			}
			String uniqueName = name;
			for (int i=1; newPathMap.containsKey(uniqueName); ++i) {
				uniqueName = String.format("%s %s", name, i);
			}
			newPathMap.put(uniqueName, path.toString());
		}
	}
		
	static RDFPath convert03xStringPathToRDFPath(List<String> oldPath) throws Exception
	{
		RDFPath newPath = new RDFPath();
		 // skip the first element, which is the Input/Output class
		for (String s: oldPath.subList(1, oldPath.size())) {
			Matcher matcher = oldPathPattern.matcher(s);
			if (matcher.find()) {
				String propertyURI = OnymizeUtils.createLabelURI(matcher.group(1), "UTF-8");
				String classURI = OnymizeUtils.createLabelURI(matcher.group(2), "UTF-8");
				newPath.add(ResourceFactory.createProperty(propertyURI),
						ResourceFactory.createResource(classURI));
			} else {
				throw new IllegalArgumentException(oldPath.toString());
			}
		}
		return newPath;
	}
}
