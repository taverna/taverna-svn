package uk.org.taverna.scufl2.api.common;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;

/**
 * A {@link Set} of {@link Named} objects.
 * <p>
 * This set will guarantee to never contain more than one {@link Named} object
 * per {@link Named#getName()}.
 * <p>
 * It is also possible to retrieve values by name using
 * {@link #getByName(String)}, or remove using {@link #removeByName(String)}.
 * The names can also be found in {@link #getNames()} and
 * {@link #nameIterator()}
 * <p>
 * Internally this set is backed by a {@link TreeMap}.
 * 
 * @author Stian Soiland-Reyes
 * 
 * @param <T>
 *            Subclass of {@link Named} to keep in this set.
 */
public class NamedSet<T extends Named> extends AbstractSet<T> implements
		SortedSet<T> {

	protected transient SortedMap<String, T> namedMap;

	/**
	 * Construct an empty NamedSet.
	 */
	public NamedSet() {
		namedMap = new TreeMap<String, T>();
	}

	/**
	 * Construct a named set containing all the elements of the given
	 * collection.
	 * <p>
	 * If the collection contains several {@link Named} elements with the same
	 * name, only the last of those elements will be in the new NamedSet.
	 *
	 * @param collection
	 *            Collection which elements are to be added to the set.
	 */
	public NamedSet(Collection<? extends T> collection) {
		namedMap = new TreeMap<String, T>();
		addAll(collection);
	}

	@Override
	public boolean add(T named) {
		return namedMap.put(named.getName(), named) == null;
	}

	/**
	 * Add the element with a unique name if the name already exist.
	 * <p>
	 * Similar to {@link #add(Named)}, but if a (object identity) different
	 * element with the same name already exists in the set, the element to be
	 * inserted will be given a unique name before inserting.
	 * <p>
	 * This means that inserting the same object instance a second time will
	 * have no effect, as with {@link #add(Named)}.
	 * <p>
	 * The unique name is generated by appending <code>_x</code> to the existing
	 * name, where x is a number from 2 or higher. An existing numeric prefix
	 * will first be removed.
	 * <p>
	 * For example, if the set already contains elements named "fish", "fish_2"
	 * and "fish_5", but you try to insert a different element which is named
	 * "fish" or "fish_5", it will be renamed to "fish_3" before inserting.
	 * <p>
	 * <strong>Note:</strong> If the element is a {@link Child} instance, and
	 * it's {@link Child#getParent()} is not <code>null</code> (or this set) the
	 * renaming could potentially cause a conflict in the old parent set. (In
	 * the example above, if the element's old parent has a child "fish_3" it
	 * will be overwritten by this instance).
	 *
	 * @param element
	 * @return The final {@link T#getName()} after insertion
	 */
	public String addWithUniqueName(T element) {
		String name = element.getName();
		T existing = getByName(name);
		if (element == existing) {
			return name;
		}

		// Remove any existing number suffix
		String nameTemplate = name.replaceAll("_\\d+$", "_");

		long i = 1;
		while (getNames().contains(name)) {
			name = nameTemplate + i++;
		}

		element.setName(name);
		add(element);
		return name;
	}

	@Override
	public void clear() {
		namedMap.clear();
	}

	@SuppressWarnings("unchecked")
	@Override
	public NamedSet<T> clone() {
		NamedSet<T> copy;
		try {
			copy = (NamedSet<T>) super.clone();
		} catch (CloneNotSupportedException e) {
			throw new IllegalStateException(e);
		}
		if (!(this.namedMap instanceof TreeMap)) {
			throw new IllegalStateException("Can't clone submap");
		}
		copy.namedMap = (SortedMap<String, T>) ((TreeMap) this.namedMap)
				.clone();
		return copy;
	}

	@Override
	public Comparator<? super T> comparator() {
		return null;
	}

	/**
	 * Return <code>true</code> if the NamedSet contains the given object, as
	 * compared using its {@link Object#equals(Object)} method.
	 * <p>
	 * Note that if a different object with the same name exist, this method
	 * will return <code>false</code>. To check for existence of a name, use
	 * {@link #containsName(String)}.
	 *
	 * @see Collection#contains(Object)
	 * @param o
	 * @return
	 */
	@Override
	public boolean contains(Object o) {
		if (!(o instanceof Named)) {
			return false;
		}
		Named named = (Named) o;
		return named.equals(namedMap.get(named.getName()));
	}

	/**
	 * Return <code>true</code> if the NamedSet contains an element with the
	 * given name.
	 *
	 * @param name
	 *            Name of object
	 * @return <code>true</code> if an element with given name is in set
	 */
	public boolean containsName(String name) {
		return namedMap.containsKey(name);
	}

	@Override
	public T first() {
		return namedMap.get(namedMap.firstKey());
	}

	/**
	 * Return the element with the given name from the set.
	 *
	 * @param name
	 * @return
	 */
	public T getByName(String name) {
		return namedMap.get(name);
	}

	public Set<String> getNames() {
		return namedMap.keySet();
	}

	@Override
	public SortedSet<T> headSet(T toElement) {
		// FIXME: Return a view instead of a copy
		NamedSet<T> headSet = new NamedSet<T>();
		headSet.namedMap = namedMap.headMap(toElement.getName());
		return headSet;
	}

	@Override
	public boolean isEmpty() {
		return namedMap.isEmpty();
	}

	@Override
	public Iterator<T> iterator() {
		return namedMap.values().iterator();
	}

	@Override
	public T last() {
		return namedMap.get(namedMap.lastKey());
	}

	public Iterator<String> nameIterator() {
		return namedMap.keySet().iterator();
	}

	@Override
	public boolean remove(Object o) {
		if (!(o instanceof Named)) {
			return false;
		}
		Named named = (Named) o;
		String name = named.getName();
		T exists = namedMap.get(name);
		if (named.equals(exists)) {
			return namedMap.remove(named.getName()) != null;
		}
		return false;
	}

	public T removeByName(String name) {
		return namedMap.remove(name);
	}

	@Override
	public int size() {
		return namedMap.size();
	}

	@Override
	public SortedSet<T> subSet(T fromElement, T toElement) {
		NamedSet<T> headSet = new NamedSet<T>();
		headSet.namedMap = namedMap.subMap(fromElement.getName(),
				toElement.getName());
		return headSet;
	}

	@Override
	public SortedSet<T> tailSet(T fromElement) {
		NamedSet<T> headSet = new NamedSet<T>();
		headSet.namedMap = namedMap.tailMap(fromElement.getName());
		return headSet;
	}

}
