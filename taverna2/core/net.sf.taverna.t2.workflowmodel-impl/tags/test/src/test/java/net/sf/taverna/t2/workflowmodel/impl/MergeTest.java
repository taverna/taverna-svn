package net.sf.taverna.t2.workflowmodel.impl;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import net.sf.taverna.t2.invocation.InvocationContext;import net.sf.taverna.t2.invocation.WorkflowDataToken;import net.sf.taverna.t2.reference.IdentifiedList;import net.sf.taverna.t2.reference.ReferenceService;import net.sf.taverna.t2.reference.T2Reference;import net.sf.taverna.t2.reference.T2ReferenceType;import net.sf.taverna.t2.workflowmodel.Dataflow;import net.sf.taverna.t2.workflowmodel.Edits;import net.sf.taverna.t2.workflowmodel.EditsRegistry;import net.sf.taverna.t2.workflowmodel.Merge;import net.sf.taverna.t2.workflowmodel.MergeInputPort;import net.sf.taverna.t2.workflowmodel.WorkflowStructureException;import net.sf.taverna.t2.workflowmodel.invocation.impl.DummyInvocationContext;import net.sf.taverna.t2.workflowmodel.processor.DiagnosticEventHandler;import org.junit.Before;import org.junit.Test;public class MergeTest {	private static final String FIRST_PROCESS = "firstProcess";	private static final String SECOND_PROCESS = "secondProcess";	private static final String DATA0 = "A string";	private static final String DATA1 = "Some other string";	private final class EventKeeper extends DiagnosticEventHandler {		public List<WorkflowDataToken> events = new ArrayList<WorkflowDataToken>();		@Override		public synchronized void receiveEvent(WorkflowDataToken token) {			super.receiveEvent(token);			events.add(token);		}	}	private InvocationContext context = new DummyInvocationContext();	private EventKeeper diagnostic;	private WorkflowDataToken token0;	private WorkflowDataToken token1;	private MergeInputPort in0;	private MergeInputPort in1;	Edits edits = EditsRegistry.getEdits();	private Merge myMerge;	private Dataflow dataflow;	private MergeOutputPortImpl outputPort;	private ReferenceService rs;	@Before	public void makeWorkflow() throws Exception {		dataflow = edits.createDataflow();		myMerge = edits.createMerge(dataflow);		edits.getAddMergeEdit(dataflow, myMerge).doEdit();		in0 = edits.createMergeInputPort(myMerge, "in0", 0);		edits.getAddMergeInputPortEdit(myMerge, in0).doEdit();		in1 = edits.createMergeInputPort(myMerge, "in1", 0);		edits.getAddMergeInputPortEdit(myMerge, in1).doEdit();		diagnostic = new EventKeeper();		outputPort = (MergeOutputPortImpl) myMerge.getOutputPort();		outputPort.addOutgoingLink(new DatalinkImpl(outputPort, diagnostic));		rs = context.getReferenceService();		token0 = new WorkflowDataToken(FIRST_PROCESS, new int[0], rs.register(				DATA0, 0, true, context), context);		token1 = new WorkflowDataToken(FIRST_PROCESS, new int[0], rs.register(				DATA1, 0, true, context), context);	}	/**	 * Assert that a simple merge with two inputs pass along both inputs, with	 * new indexes.	 * 	 * @throws Exception	 */	@Test	public void simpleMerge() throws Exception {		assertEquals(0, diagnostic.events.size());		in0.receiveEvent(token0);		assertEquals(1, diagnostic.events.size());		WorkflowDataToken receivedToken = diagnostic.events.get(0);		assertEquals(token0.getContext(), receivedToken.getContext());		assertEquals(token0.getData(), receivedToken.getData());		assertTrue(token0.isFinal());		assertEquals(0, token0.getIndex().length);		assertEquals(1, receivedToken.getIndex().length);		// From first (0) link		assertEquals(0, receivedToken.getIndex()[0]);		assertFalse(receivedToken.isFinal());		in1.receiveEvent(token1);		assertNotSame(diagnostic.events.get(0), diagnostic.events.get(1));		receivedToken = diagnostic.events.get(1);		assertEquals(token1.getContext(), receivedToken.getContext());		assertEquals(token1.getData(), receivedToken.getData());		assertTrue(token1.isFinal());		assertEquals(0, token1.getIndex().length);		assertEquals(1, receivedToken.getIndex().length);		// From second (1) link		assertEquals(1, receivedToken.getIndex()[0]);		assertFalse(receivedToken.isFinal());	}	/**	 * Assert that the order (index) within the merged list is according to the	 * order the links have been created, not the order the events are received	 * in.	 * 	 * @throws Exception	 */	@Test	public void correctOrder() throws Exception {		assertEquals(0, diagnostic.events.size());		in1.receiveEvent(token1);		assertEquals(1, diagnostic.events.size());		WorkflowDataToken receivedToken = diagnostic.events.get(0);		assertEquals(token1.getContext(), receivedToken.getContext());		assertEquals(token1.getData(), receivedToken.getData());		assertTrue(token1.isFinal());		assertEquals(0, token1.getIndex().length);		assertEquals(1, receivedToken.getIndex().length);		// From second (1) link		assertEquals(1, receivedToken.getIndex()[0]);		assertFalse(receivedToken.isFinal());		in0.receiveEvent(token0);		assertNotSame(diagnostic.events.get(0), diagnostic.events.get(1));		receivedToken = diagnostic.events.get(1);		assertEquals(token0.getContext(), receivedToken.getContext());		assertEquals(token0.getData(), receivedToken.getData());		assertTrue(token0.isFinal());		assertEquals(0, token0.getIndex().length);		assertEquals(1, receivedToken.getIndex().length);		// From first (0) link		assertEquals(0, receivedToken.getIndex()[0]);		assertFalse(receivedToken.isFinal());		// Including the completing list event		assertEquals(3, diagnostic.events.size());	}	@Test	public void manyMerge() throws Exception {		MergeInputPort in2 = edits.createMergeInputPort(myMerge, "in2", 0);		edits.getAddMergeInputPortEdit(myMerge, in2).doEdit();		MergeInputPort in3 = edits.createMergeInputPort(myMerge, "in3", 0);		edits.getAddMergeInputPortEdit(myMerge, in3).doEdit();		assertEquals(0, diagnostic.events.size());		in3.receiveEvent(token0);		assertEquals(3, diagnostic.events.get(0).getIndex()[0]);		assertEquals(1, diagnostic.events.size());		in0.receiveEvent(token0);		assertEquals(0, diagnostic.events.get(1).getIndex()[0]);		in1.receiveEvent(token1);		assertEquals(1, diagnostic.events.get(2).getIndex()[0]);		in2.receiveEvent(token1);		// Including the completing list event		assertEquals(5, diagnostic.events.size());		assertEquals(2, diagnostic.events.get(3).getIndex()[0]);	}	@Test	public void completionEvent() throws Exception {		assertEquals(0, diagnostic.events.size());		// Note: Should also work in reverse order		in1.receiveEvent(token1);		assertEquals(1, diagnostic.events.size());		in0.receiveEvent(token0);		assertEquals(3, diagnostic.events.size());		WorkflowDataToken completionToken = diagnostic.events.get(2);		assertEquals(0, completionToken.getIndex().length);		assertEquals(token0.getOwningProcess(), completionToken				.getOwningProcess());		T2Reference completionData = completionToken.getData();		assertEquals(T2ReferenceType.IdentifiedList, completionData				.getReferenceType());		IdentifiedList<T2Reference> completionList = rs.getListService()				.getList(completionData);		assertEquals(2, completionList.size());		assertEquals(token0.getData(), completionList.get(0));		assertEquals(token1.getData(), completionList.get(1));		// NOTE: Integration test		Object resolved = rs.renderIdentifier(completionData, String.class,				context);		assertTrue("Did not resolve as list", resolved instanceof List);		List resolvedList = (List) resolved;		assertEquals(2, resolvedList.size());		assertEquals(DATA0, resolvedList.get(0));		assertEquals(DATA1, resolvedList.get(1));	}	@Test(expected = WorkflowStructureException.class)	public void failsDoubleCompletion() throws Exception {		in1.receiveEvent(token1);		in1.receiveEvent(token0);	}	@Test()	public void resetAfterCompletion() throws Exception {		in0.receiveEvent(token0);		in1.receiveEvent(token1);		assertEquals(3, diagnostic.events.size());		// Should now be reset, so we'll try with the different order		in1.receiveEvent(token0);		in0.receiveEvent(token1);		assertEquals(6, diagnostic.events.size());		assertFalse("Didn't get a newly registered list", diagnostic.events				.get(2).getData().equals(diagnostic.events.get(5).getData()));		T2Reference completionData = diagnostic.events.get(5).getData();		IdentifiedList<T2Reference> completionList = rs.getListService()				.getList(completionData);		assertEquals(2, completionList.size());		// Should be the second order		assertEquals(token1.getData(), completionList.get(0));		assertEquals(token0.getData(), completionList.get(1));	}	@Test	public void parallelProcesses() throws Exception {		WorkflowDataToken alternativeToken0 = new WorkflowDataToken(				SECOND_PROCESS, new int[0], rs						.register(DATA0, 0, true, context), context);		WorkflowDataToken alternativeToken1 = new WorkflowDataToken(				SECOND_PROCESS, new int[0], rs						.register(DATA1, 0, true, context), context);		assertEquals(0, diagnostic.events.size());		// Note: Should also work in reverse order		in1.receiveEvent(token1);		assertEquals(1, diagnostic.events.size());		in0.receiveEvent(alternativeToken0);		// Note: No completion event		assertEquals(2, diagnostic.events.size());		assertEquals(FIRST_PROCESS, diagnostic.events.get(0).getOwningProcess());		assertEquals(SECOND_PROCESS, diagnostic.events.get(1)				.getOwningProcess());		assertEquals(alternativeToken0.getData(), diagnostic.events.get(1)				.getData());		in0.receiveEvent(token0);		assertEquals(4, diagnostic.events.size());		assertEquals(FIRST_PROCESS, diagnostic.events.get(2).getOwningProcess());		assertEquals(token0.getData(), diagnostic.events.get(2).getData());		assertEquals(FIRST_PROCESS, diagnostic.events.get(3).getOwningProcess());		T2Reference firstCompletion = diagnostic.events.get(3).getData();		IdentifiedList<T2Reference> firstList = rs.getListService().getList(				firstCompletion);		assertEquals(2, firstList.size());		assertEquals(token0.getData(), firstList.get(0));		assertEquals(token1.getData(), firstList.get(1));		in1.receiveEvent(alternativeToken1);		assertEquals(6, diagnostic.events.size());		assertEquals(SECOND_PROCESS, diagnostic.events.get(4)				.getOwningProcess());		assertEquals(alternativeToken1.getData(), diagnostic.events.get(4)				.getData());		assertEquals(SECOND_PROCESS, diagnostic.events.get(5)				.getOwningProcess());		T2Reference secondCompletion = diagnostic.events.get(5).getData();		IdentifiedList<T2Reference> secondList = rs.getListService().getList(				secondCompletion);		assertEquals(2, secondList.size());		assertEquals(alternativeToken0.getData(), secondList.get(0));		assertEquals(alternativeToken1.getData(), secondList.get(1));	}}