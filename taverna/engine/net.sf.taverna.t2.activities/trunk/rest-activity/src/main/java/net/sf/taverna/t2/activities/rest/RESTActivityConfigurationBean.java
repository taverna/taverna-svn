package net.sf.taverna.t2.activities.rest;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import net.sf.taverna.t2.workflowmodel.processor.activity.config.ActivityPortsDefinitionBean;
import net.sf.taverna.t2.workflowmodel.processor.config.ConfigurationBean;
import net.sf.taverna.t2.workflowmodel.processor.config.ConfigurationProperty;

/**
 * Beans of this class store configuration information for REST activities. Configuration is
 * comprised of the HTTP method to use, URL signature, and MIME types for Accept and Content-Type
 * HTTP request headers. Additional value is used to record the format of outgoing data - binary or
 * string. <br/>
 * <br/>
 *
 * Also, derived attribute "activityInputs" is generated by identifying all "input ports" in the
 * provided URL signature. <br/>
 * <br/>
 *
 * Complete request URL (obtained by substituting values into the placeholders of the URL signature)
 * is not stored, as it represents an instantiation of the activity invocation. The same applies for
 * the input message body sent along with POST / PUT requests.
 *
 * @author Sergejs Aleksejevs
 */
@SuppressWarnings("serial")
@ConfigurationBean(uri = RESTActivity.URI + "#Config")
public class RESTActivityConfigurationBean extends ActivityPortsDefinitionBean implements Serializable {
	private RESTActivity.HTTP_METHOD httpMethod;
	private String urlSignature;
	private String acceptsHeaderValue;
	private String contentTypeForUpdates;
	private RESTActivity.DATA_FORMAT outgoingDataFormat;

	private boolean sendHTTPExpectRequestHeader;
	private boolean showRedirectionOutputPort;
	// whether to perform URL escaping of passed parameters, true by default
	private boolean escapeParameters = true;

	// list of HTTP headers (other than Accept and Content-Type) and their values
	private ArrayList<ArrayList<String>> otherHTTPHeaders = new ArrayList<ArrayList<String>>();
	// only need to store the configuration of inputs, as all of them are dynamic;
	// only inputs that constitute components of URL signature are to be stored
	// in this map all outputs are currently fixed, so no need to keep configuration of those
	private Map<String, Class<?>> activityInputs;

	private HTTPRequest request;

	/**
	 * @return An instance of the {@link RESTActivityConfigurationBean} pre-configured with default
	 *         settings for all parameters.
	 */
	public static RESTActivityConfigurationBean getDefaultInstance() {
		// TODO - set sensible default values here
		RESTActivityConfigurationBean defaultBean = new RESTActivityConfigurationBean();
		defaultBean.setHttpMethod(RESTActivity.HTTP_METHOD.GET);
		defaultBean.setAcceptsHeaderValue("application/xml");
		defaultBean.setContentTypeForUpdates("application/xml");
		defaultBean.setUrlSignature("http://www.uniprot.org/uniprot/{id}.xml");
		defaultBean.setOutgoingDataFormat(RESTActivity.DATA_FORMAT.String);
		// not ticked by default to allow to post to Twitter
		defaultBean.setSendHTTPExpectRequestHeader(false);
		// not showing the Redirection output port by default to make processor look simpler
		defaultBean.setShowRedirectionOutputPort(false);
		defaultBean.setEscapeParameters(true);
		defaultBean.setOtherHTTPHeaders(new ArrayList<ArrayList<String>>());
		return (defaultBean);
	}

	/**
	 * Tests validity of the configuration held in this bean.
	 *
	 * <br/>
	 * <br/>
	 * Performed tests are as follows: <br/>
	 * * <code>httpMethod</code> is known to be valid - it's an enum; <br/>
	 * * <code>urlSignature</code> - uses {@link URISignatureHandler#isValid(String)} to test
	 * validity; <br/>
	 * * <code>acceptsHeaderValue</code> and <code>contentTypeForUpdates</code> must not be empty.
	 *
	 * <br/>
	 * <br/>
	 * <code>contentTypeForUpdates</code> is only checked if the <code>httpMethod</code> is such
	 * that it is meant to use the Content-Type header (that is POST / PUT only).
	 *
	 * @return <code>true</code> if the configuration in the bean is valid; <code>false</code>
	 *         otherwise.
	 */
	public boolean isValid() {
		return (urlSignature != null && URISignatureHandler.isValid(urlSignature) && ((RESTActivity
				.hasMessageBodyInputPort(httpMethod)
				&& contentTypeForUpdates != null
				&& contentTypeForUpdates.length() > 0 && outgoingDataFormat != null) || !RESTActivity
					.hasMessageBodyInputPort(httpMethod)));
	}

	@ConfigurationProperty(name = "httpMethod", label = "HTTP Method")
	public void setHttpMethod(RESTActivity.HTTP_METHOD httpMethod) {
		this.httpMethod = httpMethod;
	}

	public RESTActivity.HTTP_METHOD getHttpMethod() {
		return httpMethod;
	}

	public String getUrlSignature() {
		return urlSignature;
	}

	@ConfigurationProperty(name = "absoluteURITemplate", label = "URL Template")
	public void setUrlSignature(String urlSignature) {
		this.urlSignature = urlSignature;
	}

	public String getAcceptsHeaderValue() {
		return acceptsHeaderValue;
	}

	@ConfigurationProperty(name = "acceptsHeaderValue", label = "'Accept' Header")
	public void setAcceptsHeaderValue(String acceptsHeaderValue) {
		this.acceptsHeaderValue = acceptsHeaderValue;
	}

	public String getContentTypeForUpdates() {
		return contentTypeForUpdates;
	}

	@ConfigurationProperty(name = "contentTypeForUpdates", label = "Content Type For Updates")
	public void setContentTypeForUpdates(String contentTypeForUpdates) {
		this.contentTypeForUpdates = contentTypeForUpdates;
	}

	public void setActivityInputs(Map<String, Class<?>> activityInputs) {
		this.activityInputs = activityInputs;
	}

	public Map<String, Class<?>> getActivityInputs() {
		return activityInputs;
	}

	public RESTActivity.DATA_FORMAT getOutgoingDataFormat() {
		return outgoingDataFormat;
	}

	@ConfigurationProperty(name = "outgoingDataFormat", label = "Outgoing Data Format")
	public void setOutgoingDataFormat(RESTActivity.DATA_FORMAT outgoingDataFormat) {
		this.outgoingDataFormat = outgoingDataFormat;
	}

	public boolean getSendHTTPExpectRequestHeader() {
		return sendHTTPExpectRequestHeader;
	}

	@ConfigurationProperty(name = "sendHTTPExpectRequestHeader", label = "Send HTTP Expect request-header field")
	public void setSendHTTPExpectRequestHeader(boolean sendHTTPExpectRequestHeader) {
		this.sendHTTPExpectRequestHeader = sendHTTPExpectRequestHeader;
	}

	public boolean getShowRedirectionOutputPort() {
		return showRedirectionOutputPort;
	}

	@ConfigurationProperty(name = "showRedirectionOutputPort", label = "Show 'Redirection' output port")
	public void setShowRedirectionOutputPort(boolean showRedirectionOutputPort) {
		this.showRedirectionOutputPort = showRedirectionOutputPort;
	}

	@ConfigurationProperty(name = "escapeParameters", label = "Escape URL parameter values")
	public void setEscapeParameters(boolean escapeParameters) {
		this.escapeParameters = Boolean.valueOf(escapeParameters);
	}

	public boolean getEscapeParameters() {
		return escapeParameters;
	}

	public void setOtherHTTPHeaders(ArrayList<ArrayList<String>> otherHTTPHeaders) {
		this.otherHTTPHeaders = otherHTTPHeaders;
	}

	public ArrayList<ArrayList<String>> getOtherHTTPHeaders() {
		return otherHTTPHeaders;
	}

	public HTTPRequest getRequest() {
		return request;
	}

	public void setRequest(HTTPRequest request) {
		this.request = request;
	}

}
