<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section>
    <title>Beanshell scripting</title>

    <para>There are often cases in workflow construction where the output of
    one processor is not quite right for the input of the next. There are
    various options to cover these cases - the user can make use of so called
    shim services exposed in the same way as other operations, he or she could
    create a new service to perform the transformation or, for relatively
    simple cases, he or she could create a single non service component in the
    form of a script.</para>

    <para>Beanshell scripts, as the name suggests, use the Beanshell scripting
    engine. This gives the user access to a form of interpreted Java; this
    section therefore assumes a minimal level of Java knowledge. For users who
    have never attempted Java programming we recommend the Java tutorial on
    Sun Microsystem's website at <ulink
    url="http://java.sun.com/docs/books/tutorial/">http://java.sun.com/docs/books/tutorial/</ulink>.
    There are certain minor differences between the core language described
    there and the version used by the Beanshell, these are further documented
    at the Beanshell web site at <ulink
    url="http://www.beanshell.org/">http://www.beanshell.org/</ulink> - the
    good news is that almost all these differences make it easier to use than
    conventional Java; it's unlikely a typical user would ever encounter them
    however.</para>

    <para>As an example of a simple script consider the following use case:
    Given three raw sequence strings (protein or nucleotide) create a single
    string containing the three sequences with FASTA format titles. For
    simplicity's sake assume that the titles are all fixed (although we could
    easily have the titles as parameters to the script).</para>

    <section>
      <title>Creating a new beanshell instance</title>

      <para>Create a new Beanshell processor by dragging the '<emphasis
      role="bold">Beanshell scripting host</emphasis>' from the local services
      section of the service selection panel into the advanced model
      explorer:</para>

      <screenshot>
        <screeninfo></screeninfo>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/create_beanshell.png" />
          </imageobject>
        </mediaobject>
      </screenshot>
    </section>

    <section>
      <title>Defining inputs and outputs</title>

      <para>The first things to configure, after changing the name from the
      default, are the input and output ports of the new instance. The
      Beanshell configuration panel is accessible from the right click menu of
      the new processor, selecting '<emphasis role="bold">Configure
      beanshell...</emphasis>' from the menu:</para>

      <screenshot>
        <screeninfo></screeninfo>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/configure_beanshell.png" />
          </imageobject>
        </mediaobject>
      </screenshot>

      <para>This will open a new window containing options to configure the
      script itself and the inputs and outputs. Selecting the '<emphasis
      role="bold">Ports</emphasis>' tab allows the user to create, remove and
      modify the types of the inputs and outputs to this processor. A new
      input is added by entering the name in the text box to the right of the
      '<emphasis role="bold">Add Input</emphasis>' button then clicking on the
      button to create the input. The input ports appear in the Inputs list
      along with the default type '<emphasis>a Plain Text</emphasis>'
      corresponding to a single string with no additional MIME type
      information. Although in this case the default is the correct value this
      can be changed by selecting either the 'Plain Text' at which a drop down
      list will present the available types, or the 'a', in which case options
      are available to cycle through the collection types such as '<emphasis>a
      list of</emphasis>'. Leave the defaults for now and use the port
      creation mechanism described above to create three inputs and one output
      with sensible names: </para>

      <screenshot>
        <screeninfo></screeninfo>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/add_beanshell_output.png" />
          </imageobject>
        </mediaobject>
      </screenshot>
    </section>

    <section>
      <title>Configuring the script</title>

      <para>Now the processor has the correct inputs and outputs the remaining
      task is to specify the logic connecting these together in the form of a
      script. Selecting the 'Script' tab makes available a syntax highlighting
      editor (based on JEdit) into which the user must enter a Beanshell
      compatible script:</para>

      <screenshot>
        <screeninfo></screeninfo>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/beanshell_script.png" />
          </imageobject>
        </mediaobject>
      </screenshot>

      <para>Having defined the available ports (both inputs and outputs) the
      script engine will, when this processor is enacted, create new bound
      variables in the scripting environment corresponding to the names of the
      input ports. It will extract bound variables with names corresponding to
      the output ports at the end of the invocation, and use the values of
      these as the output values of the processor. In this case therefore the
      script must make use of the variables named '<emphasis
      role="bold">seq1</emphasis>', '<emphasis role="bold">seq2</emphasis>'
      and '<emphasis role="bold">seq3</emphasis>' and ensure that there is a
      variable of the appropriate type called '<emphasis
      role="bold">fasta</emphasis>' bound in the environment when the script
      completes. The types are determined by the '<emphasis>a</emphasis>',
      '<emphasis>a list of</emphasis>' ... options in the <emphasis
      role="bold">Ports</emphasis> section - if the type is a single
      <emphasis>Plain Text</emphasis> the variable bound to it will be a
      String object, if a <emphasis>list of Plain Text</emphasis> the value
      will be a Java <emphasis>List</emphasis> implementation where the items
      in the <emphasis>List</emphasis> are <emphasis>String</emphasis> objects
      and so on. Corresponding logic applies to the output - if the <emphasis
      role="bold">Ports</emphasis> section declares that there is an output
      called '<emphasis role="bold">fasta</emphasis>' with type '<emphasis>a
      Plain Text</emphasis>' the script must, before it completes, define a
      <emphasis>String</emphasis> called '<emphasis
      role="bold">fasta</emphasis>' containing that result value.</para>

      <para>The image below shows a script (more verbose than strictly
      required) which fulfils this contract and performs the desired function,
      those familiar with Java will realize that this could be done in a
      single line:</para>

      <screenshot>
        <screeninfo></screeninfo>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/makefasta_beanshell.png" />
          </imageobject>
        </mediaobject>
      </screenshot>

      <para>When the script is changed the user must click on the '<emphasis
      role="bold">Save Script Changes</emphasis>' button - this commits any
      changes to the script text back into the processor definition. </para>
    </section>

    <section>
      <title>Sharing and reuse of scripts</title>

      <para>Because the Beanshell processor only exists as part of a workflow
      (unlike, for example, a SOAP service which exists on some networked
      resource) there is a potential problem with reuse - having written a
      potentially complex script it would clearly be desirable to share and
      allow some level of reuse but because the script is within a workflow it
      cannot be simply found as a networked service can be. Fortunately it is
      possible to share scripts by creating a workflow containing the script
      and making the workflow definition available online - this can then be
      used as the target for either a web crawl or single workflow scavenger
      which will in turn expose the script as a child element of the workflow
      scavenger. The script can then be treated exactly as any other processor
      located in this way. </para>
    </section>
  </section>